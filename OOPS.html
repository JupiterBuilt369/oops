<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Output & Error Prediction Quiz (Ultimate 250)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for code blocks */
        pre::-webkit-scrollbar { height: 8px; }
        pre::-webkit-scrollbar-track { background: #1f2937; border-radius: 4px; }
        pre::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .code-keyword { color: #f9a8d4; }
        .code-string { color: #86efac; }
        .code-comment { color: #9ca3af; font-style: italic; }
        .code-class { color: #93c5fd; }
        .code-method { color: #fcd34d; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans antialiased pb-12">

    <header class="bg-blue-600 text-white shadow-lg py-6 mb-8 sticky top-0 z-50">
        <div class="max-w-4xl mx-auto px-4 flex justify-between items-center">
            <div>
                <h1 class="text-3xl font-bold">â˜• Java Brain Teasers</h1>
                <p class="mt-1 text-blue-100 text-sm">The Ultimate 250 Output & Error Prediction Questions</p>
            </div>
            <div class="bg-blue-800 px-4 py-2 rounded-lg text-sm font-semibold shadow-inner border border-blue-700">
                250 Questions
            </div>
        </div>
    </header>

    <main id="quiz-container" class="max-w-4xl mx-auto px-4 space-y-8">
        <!-- Questions load dynamically -->
        <div class="text-center py-12 text-gray-500">
            <svg class="animate-spin h-8 w-8 mx-auto mb-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p>Loading the ultimate challenge...</p>
        </div>
    </main>

    <script>
        const questions = [
            // Part 1: Original 50
            {title:"Question 1: The Classic Overload Trap",tag:"Method Overloading",code:`public class Main {\n    public static void print(Object o) { System.out.println("Object"); }\n    public static void print(String s) { System.out.println("String"); }\n    public static void main(String[] args) { print(null); }\n}`,options:["A) Object","B) String","C) Compilation Error","D) NPE"],correct:1,exp:"The compiler chooses the most specific matching method. String is a subclass of Object, so it wins."},
            {title:"Question 2: Try-Catch-Finally Returns",tag:"Exceptions",code:`public class Main {\n    public static int test() {\n        try { return 1; } \n        catch (Exception e) { return 2; } \n        finally { return 3; }\n    }\n    public static void main(String[] args) { System.out.println(test()); }\n}`,options:["A) 1","B) 2","C) 3","D) Compilation Error"],correct:2,exp:"The finally block always executes. Its return statement silently overrides any previous returns."},
            {title:"Question 3: Execution Order",tag:"Initialization",code:`class A {\n    static { System.out.print("1 "); }\n    { System.out.print("2 "); }\n    A() { System.out.print("3 "); }\n}\npublic class Main {\n    public static void main(String[] args) { new A(); new A(); }\n}`,options:["A) 1 2 3 1 2 3","B) 1 2 3 2 3","C) 2 3 1 2 3","D) 1 2 2 3 3"],correct:1,exp:"Static blocks run once per class load. Instance blocks run before the constructor on every instantiation."},
            {title:"Question 4: Variable Hiding vs Overriding",tag:"Polymorphism",code:`class Parent { int x = 10; void show() { System.out.print("P "); } }\nclass Child extends Parent { int x = 20; void show() { System.out.print("C "); } }\npublic class Main {\n    public static void main(String[] args) {\n        Parent obj = new Child();\n        obj.show(); System.out.print(obj.x);\n    }\n}`,options:["A) P 10","B) C 20","C) C 10","D) P 20"],correct:2,exp:"Methods are dynamically overridden at runtime (Child), but variables are statically hidden at compile time based on reference type (Parent)."},
            {title:"Question 5: String Equality",tag:"String Pool",code:`public class Main {\n    public static void main(String[] args) {\n        String s1 = "Java"; String s2 = new String("Java");\n        System.out.print((s1 == s2) + " " + (s1 == s2.intern()));\n    }\n}`,options:["A) true true","B) false false","C) false true","D) true false"],correct:2,exp:"s2 uses 'new' creating a heap object (false). intern() returns the pool reference which matches s1 (true)."},
            {title:"Question 6: Integer Caching",tag:"Memory",code:`public class Main {\n    public static void main(String[] args) {\n        Integer a = 127, b = 127, c = 128, d = 128;\n        System.out.println((a == b) + " " + (c == d));\n    }\n}`,options:["A) true true","B) false false","C) true false","D) false true"],correct:2,exp:"Java caches Integer values from -128 to 127. Values outside this range create new distinct objects."},
            {title:"Question 7: String Math Precedence",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.println(10 + 20 + "Java" + 10 + 20);\n    }\n}`,options:["A) 30Java30","B) 1020Java1020","C) 30Java1020","D) Compilation Error"],correct:2,exp:"Evaluates left-to-right. 10+20=30. Then '30Java'. After string conversion, remaining operators perform string concatenation."},
            {title:"Question 8: The Zero Division Paradox",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(0.0 / 0.0); }\n}`,options:["A) 0.0","B) Infinity","C) NaN","D) ArithmeticException"],correct:2,exp:"Floating-point division by zero follows IEEE 754. 0.0/0.0 is Not-a-Number (NaN)."},
            {title:"Question 9: The Unreachable Finally",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        try { System.exit(0); } \n        finally { System.out.println("Finally"); }\n    }\n}`,options:["A) Prints 'Finally'","B) Does not print anything","C) Compilation Error","D) Runtime Exception"],correct:1,exp:"System.exit() terminates the JVM immediately, bypassing the finally block entirely."},
            {title:"Question 10: Ternary Type Promotion",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        Object o = true ? new Integer(1) : new Double(2.0);\n        System.out.println(o);\n    }\n}`,options:["A) 1","B) 1.0","C) Compilation Error","D) ClassCastException"],correct:1,exp:"Ternary operator promotes the lower precision type to the higher precision type (Integer becomes Double)."},
            {title:"Question 11: Ambiguous Varargs",tag:"Overloading",code:`public class Main {\n    static void test(int... x) { System.out.print("int"); }\n    static void test(Integer... x) { System.out.print("Integer"); }\n    public static void main(String[] args) { test(1, 2); }\n}`,options:["A) int","B) Integer","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The compiler prefers primitive varargs over wrapper class varargs to avoid autoboxing overhead."},
            {title:"Question 12: List Removal",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        list.add(1); list.add(2); list.add(3); list.remove(1);\n        System.out.println(list);\n    }\n}`,options:["A) [2, 3]","B) [1, 3]","C) [1, 2]","D) Exception"],correct:1,exp:"remove(1) resolves to remove(int index), not remove(Object o). It removes the element at index 1 (which is 2)."},
            {title:"Question 13: Assignment Condition",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        boolean b = false;\n        if (b = true) { System.out.println("Yes"); } \n        else { System.out.println("No"); }\n    }\n}`,options:["A) Yes","B) No","C) Compilation Error","D) Runtime Error"],correct:0,exp:"b = true assigns true to b AND evaluates to true, so the if-block executes."},
            {title:"Question 14: Null Reference Static Call",tag:"Statics",code:`class Test { static void hello() { System.out.print("Hi"); } }\npublic class Main {\n    public static void main(String[] args) {\n        Test t = null; t.hello();\n    }\n}`,options:["A) Hi","B) NullPointerException","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Static methods belong to the class. t.hello() compiles to Test.hello(), avoiding the NPE."},
            {title:"Question 15: Exception Masking",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        try { throw new RuntimeException("Try"); } \n        finally { throw new RuntimeException("Finally"); }\n    }\n}`,options:["A) Throws 'Try'","B) Throws 'Finally'","C) Compilation Error","D) Throws both"],correct:1,exp:"Exceptions thrown in a finally block override/mask any exceptions thrown in the try block."},
            {title:"Question 16: Pass by Value",tag:"References",code:`public class Main {\n    static void change(String s) { s = "New"; }\n    public static void main(String[] args) {\n        String str = "Old"; change(str);\n        System.out.println(str);\n    }\n}`,options:["A) Old","B) New","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Java passes references by value. Reassigning 's' in the method does not affect the original reference."},
            {title:"Question 17: Infinite Construction",tag:"Constructors",code:`class Test {\n    Test() { new Test(); }\n    public static void main(String[] args) { new Test(); }\n}`,options:["A) StackOverflowError","B) OutOfMemoryError","C) Compilation Error","D) Terminates normally"],correct:0,exp:"The constructor recursively calls itself infinitely, blowing up the call stack."},
            {title:"Question 18: Thread Run vs Start",tag:"Multithreading",code:`public class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> System.out.print("T "));\n        t.run(); System.out.print("M");\n    }\n}`,options:["A) T M","B) M T","C) Compilation Error","D) Random Order"],correct:0,exp:"Calling run() executes the code synchronously on the current thread. start() must be used for concurrency."},
            {title:"Question 19: Catch Ordering Trap",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        try { throw new java.io.IOException(); }\n        catch (Exception e) { System.out.print("Exception "); }\n        catch (java.io.IOException e) { System.out.print("IO "); }\n    }\n}`,options:["A) Exception","B) IO","C) Compilation Error","D) Both print"],correct:2,exp:"Compilation Error. Exception catches everything, making the subclass IOException block strictly unreachable."},
            {title:"Question 20: Autoboxing Trap",tag:"Wrappers",code:`public class Main {\n    public static void main(String[] args) {\n        Integer i = null; int j = i; System.out.println(j);\n    }\n}`,options:["A) null","B) 0","C) Compilation Error","D) NullPointerException"],correct:3,exp:"Assigning a null wrapper to a primitive forces an implicit unboxing (i.intValue()), triggering an NPE."},
            {title:"Question 21: StringBuilder Equality",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        StringBuilder s1 = new StringBuilder("J");\n        StringBuilder s2 = new StringBuilder("J");\n        System.out.println(s1.equals(s2));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"StringBuilder does not override equals(). It falls back to Object.equals() which compares memory references."},
            {title:"Question 22: Compound Assignment",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        short s = 5; s += 10; s = s + 5; System.out.println(s);\n    }\n}`,options:["A) 20","B) Compilation Error","C) Runtime Error","D) 0"],correct:1,exp:"s += 10 auto-casts, but s + 5 promotes to int. Assigning an int back to short requires an explicit cast."},
            {title:"Question 23: Map Overwriting",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        Map<String, String> m = new HashMap<>();\n        m.put("A", "1"); m.put("A", "2");\n        System.out.println(m.size());\n    }\n}`,options:["A) 1","B) 2","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Maps cannot have duplicate keys. The second put() simply overwrites the value for key 'A'."},
            {title:"Question 24: String Immutability",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        String s = " Hi "; s.trim(); System.out.println(s.length());\n    }\n}`,options:["A) 2","B) 4","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Strings are immutable. trim() returns a new String, but since it wasn't reassigned, the original 's' remains length 4."},
            {title:"Question 25: Absolute Edge Case",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(Math.abs(Integer.MIN_VALUE)); }\n}`,options:["A) 2147483648","B) 2147483647","C) -2147483648","D) 0"],correct:2,exp:"Integer overflow. The absolute value of MIN_VALUE exceeds MAX_VALUE, wrapping back to a negative number."},
            {title:"Question 26: Float Division by Zero",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(1.0 / 0); }\n}`,options:["A) Compilation Error","B) ArithmeticException","C) Infinity","D) NaN"],correct:2,exp:"Floating-point division by 0 does not throw an exception; it results in Infinity per IEEE 754."},
            {title:"Question 27: Minimum Double Value",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(Math.min(Double.MIN_VALUE, 0.0d)); }\n}`,options:["A) 0.0","B) Double.MIN_VALUE","C) -Infinity","D) Error"],correct:0,exp:"Double.MIN_VALUE is the smallest POSITIVE non-zero fraction. It is greater than 0.0."},
            {title:"Question 28: Not a Number",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(Double.NaN == Double.NaN); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"By definition, NaN is never equal to anything, including itself. Use Double.isNaN() instead."},
            {title:"Question 29: Interface Variables",tag:"Interfaces",code:`interface I { int x = 10; }\npublic class Main implements I {\n    public static void main(String[] args) { x = 20; System.out.println(x); }\n}`,options:["A) 20","B) 10","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Interface variables are implicitly public static final. You cannot reassign a final variable."},
            {title:"Question 30: Unreachable Code",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        while (false) { System.out.println("Hi"); }\n        System.out.println("World");\n    }\n}`,options:["A) Hi World","B) World","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Java prevents compiling strictly unreachable code (while(false) blocks)."},
            {title:"Question 31: Char Addition",tag:"Types",code:`public class Main {\n    public static void main(String[] args) { System.out.println('A' + 'B'); }\n}`,options:["A) AB","B) 131","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The + operator on chars performs arithmetic on their ASCII values: 65 + 66 = 131."},
            {title:"Question 32: Arrays asList Mutation",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        List<String> list = java.util.Arrays.asList("A", "B");\n        list.add("C"); System.out.println(list.size());\n    }\n}`,options:["A) 2","B) 3","C) Compilation Error","D) UnsupportedOperationException"],correct:3,exp:"Arrays.asList returns a fixed-size wrapper. You can change elements, but adding/removing throws exceptions."},
            {title:"Question 33: Empty For Loop",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        for (;;) { System.out.println("Inf"); break; }\n    }\n}`,options:["A) Compilation Error","B) Inf","C) Runtime Error","D) Nothing"],correct:1,exp:"for(;;) is perfectly valid syntax for an infinite loop. The break statement exits it immediately after printing."},
            {title:"Question 34: Finally Returns Again",tag:"Exceptions",code:`public class Main {\n    public static boolean test() {\n        try { return true; } finally { return false; }\n    }\n    public static void main(String[] args) { System.out.print(test()); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The finally block intercepts the return true and forces a return false."},
            {title:"Question 35: The i++ Trap",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        int i = 0; i = i++; System.out.println(i);\n    }\n}`,options:["A) 0","B) 1","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The post-increment yields 0, increments i to 1 in memory, then the assignment overwrites i back to the yielded 0."},
            {title:"Question 36: Optional Null",tag:"Optionals",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.Optional<String> o = java.util.Optional.of(null);\n        System.out.println(o.isPresent());\n    }\n}`,options:["A) true","B) false","C) NullPointerException","D) Compilation Error"],correct:2,exp:"Optional.of() strictly rejects nulls and throws NPE. Use Optional.ofNullable() to allow nulls."},
            {title:"Question 37: Boolean Constructor",tag:"Wrappers",code:`public class Main {\n    public static void main(String[] args) {\n        Boolean b = new Boolean("tRue"); System.out.println(b);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The Boolean String constructor ignores case. Any variation of 'true' resolves to true."},
            {title:"Question 38: Set Addition",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.Set<Integer> set = new java.util.HashSet<>();\n        set.add(1); System.out.println(set.add(1));\n    }\n}`,options:["A) 1","B) true","C) false","D) Compilation Error"],correct:2,exp:"Set.add() returns false if the element is already present in the set."},
            {title:"Question 39: The Null Print",tag:"IO",code:`public class Main {\n    public static void main(String[] args) {\n        Object obj = null; System.out.println(obj);\n    }\n}`,options:["A) null","B) NullPointerException","C) Compilation Error","D) Runtime Error"],correct:0,exp:"println converts null references safely to the string literal 'null'."},
            {title:"Question 40: Overloading Null Cast",tag:"Overloading",code:`public class Main {\n    static void test(String s) { System.out.print("S"); }\n    static void test(Integer i) { System.out.print("I"); }\n    public static void main(String[] args) { test((Integer) null); }\n}`,options:["A) S","B) I","C) Compilation Error","D) NPE"],correct:1,exp:"Explicitly casting null to Integer removes the ambiguity, resolving to the Integer overload."},
            {title:"Question 41: Main Overloading",tag:"Execution",code:`public class Main {\n    public static void main(String[] args) { System.out.print("1"); main(new int[]{}); }\n    public static void main(int[] args) { System.out.print("2"); }\n}`,options:["A) 1","B) 2","C) 12","D) Compilation Error"],correct:2,exp:"The main method can be overloaded. The JVM automatically starts with String[] args, which then manually calls the other."},
            {title:"Question 42: Array Type Safety",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        Object[] arr = new String[2]; arr[0] = 10; System.out.println(arr[0]);\n    }\n}`,options:["A) 10","B) Compilation Error","C) ArrayStoreException","D) NPE"],correct:2,exp:"Arrays are covariant, so compiling succeeds. But at runtime, putting an Integer into a String[] throws ArrayStoreException."},
            {title:"Question 43: Final Reassignment",tag:"Modifiers",code:`public class Main {\n    public static void main(String[] args) {\n        final int x; x = 10; x = 20; System.out.println(x);\n    }\n}`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:2,exp:"A 'blank final' can be assigned exactly once. The second assignment triggers a compiler error."},
            {title:"Question 44: Switch Fallthrough",tag:"Switch",code:`public class Main {\n    public static void main(String[] args) {\n        int x = 5;\n        switch(x) { default: System.out.print("D "); case 1: System.out.print("1"); }\n    }\n}`,options:["A) D","B) D 1","C) Compilation Error","D) 1"],correct:1,exp:"The default block triggers because 5 has no case. Since there is no break, it falls through into case 1."},
            {title:"Question 45: String Literal vs Object",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        String s1 = "Java"; String s2 = "Ja" + "va";\n        System.out.println(s1 == s2);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The compiler performs constant folding on string literals. 'Ja' + 'va' resolves at compile time to the pooled 'Java'."},
            {title:"Question 46: Double NaN Checks",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        double d = Double.NaN; System.out.println(Double.isNaN(d) == (d != d));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Because NaN == NaN is false, d != d is a valid way to check for NaN. Both sides evaluate to true."},
            {title:"Question 47: PriorityQueue Order",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.PriorityQueue<Integer> pq = new java.util.PriorityQueue<>();\n        pq.add(3); pq.add(1); pq.add(2); System.out.println(pq);\n    }\n}`,options:["A) [1, 2, 3]","B) [3, 1, 2]","C) [1, 3, 2]","D) Random"],correct:2,exp:"PriorityQueue is backed by a min-heap array. The smallest is at index 0, but the rest are placed by heap logic, not strict sorting."},
            {title:"Question 48: Static Interface Methods",tag:"Interfaces",code:`interface I { static void run() { System.out.print("R"); } }\nclass Impl implements I {}\npublic class Main {\n    public static void main(String[] args) { Impl.run(); }\n}`,options:["A) R","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:1,exp:"Static methods in interfaces do not inherit. They must be invoked using the interface name: I.run()."},
            {title:"Question 49: Array Cloning",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a = {1}; int[] b = a.clone(); System.out.println(a == b);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"clone() creates a completely new array object in memory, so their memory addresses do not match."},
            {title:"Question 50: Unicode Trap",tag:"Execution",code:`public class Main {\n    public static void main(String[] args) {\n        // \\u000d System.out.print("Surprise");\n    }\n}`,options:["A) Comment ignored","B) Surprise","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Java processes unicode escapes before evaluating syntax. \\u000d acts as a newline, pushing the print statement out of the comment."},

            // Part 2: 51 - 150
            {title:"Question 51: Null Instance",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        Object o = null;\n        System.out.print(o instanceof String);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) NullPointerException"],correct:1,exp:"The instanceof operator safely handles null references, always returning false without throwing an exception."},
            {title:"Question 52: Char Array Print",tag:"IO",code:`public class Main {\n    public static void main(String[] args) {\n        char[] c = {'a', 'b', 'c'};\n        System.out.print(c);\n    }\n}`,options:["A) Memory address","B) abc","C) [a, b, c]","D) Compilation Error"],correct:1,exp:"Unlike other arrays that print memory addresses, System.out.print(char[]) is heavily overloaded to print the string representation directly."},
            {title:"Question 53: Bitwise Inversion",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        int x = ~5;\n        System.out.print(x);\n    }\n}`,options:["A) 5","B) -5","C) 6","D) -6"],correct:3,exp:"The bitwise complement operator ~ inverts all bits. Two's complement math means ~N always equals -(N + 1)."},
            {title:"Question 54: Switch on Null",tag:"Switch",code:`public class Main {\n    public static void main(String[] args) {\n        String s = null;\n        switch(s) { case "a": System.out.print("a"); }\n    }\n}`,options:["A) Prints nothing","B) Compilation Error","C) NullPointerException","D) a"],correct:2,exp:"Switch statements on Strings invoke .hashCode() and .equals() internally. Passing null causes an immediate NPE."},
            {title:"Question 55: Negative Modulo",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(-5 % 2);\n    }\n}`,options:["A) 1","B) -1","C) 2","D) -2"],correct:1,exp:"In Java, the sign of the modulo result always matches the sign of the dividend (the left operand)."},
            {title:"Question 56: Double Brace Leaks",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>() {{ add("A"); }};\n        System.out.print(list.getClass().getName().contains("$"));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Double brace initialization creates an anonymous inner class, hence the dollar sign ($) in its generated class name."},
            {title:"Question 57: Zero Length Arrays",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] arr = new int[0];\n        System.out.print(arr.length);\n    }\n}`,options:["A) 0","B) Compilation Error","C) NegativeArraySizeException","D) NullPointerException"],correct:0,exp:"Java fully permits arrays of length 0. They are not null; they are valid objects with a length property of 0."},
            {title:"Question 58: Integer Constructor Caching",tag:"Memory",code:`public class Main {\n    public static void main(String[] args) {\n        Integer a = new Integer(10);\n        Integer b = new Integer(10);\n        System.out.print(a == b);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"While Integer.valueOf(10) uses the cache, explicitly using 'new' forces new distinct objects on the heap."},
            {title:"Question 59: Rounding Negatives",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Math.round(-1.5));\n    }\n}`,options:["A) -1","B) -2","C) -1.0","D) -2.0"],correct:0,exp:"Math.round() adds 0.5 and floors the result. -1.5 + 0.5 is -1.0, which floors to -1."},
            {title:"Question 60: Unsigned Right Shift",tag:"Bitwise",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(-1 >>> 31);\n    }\n}`,options:["A) -1","B) 0","C) 1","D) 31"],correct:2,exp:"The >>> operator shifts bits to the right and fills the leftmost bits with zero, ignoring the sign bit. -1 is all 1s, shifting 31 leaves a single 1."},
            {title:"Question 61: Split Empty Trails",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        String[] parts = "a:b::".split(":");\n        System.out.print(parts.length);\n    }\n}`,options:["A) 2","B) 3","C) 4","D) 5"],correct:0,exp:"By default, String.split() discards trailing empty strings from the resulting array."},
            {title:"Question 62: Concurrent Removal",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2));\n        for (Integer i : list) { list.remove(i); }\n    }\n}`,options:["A) List is empty","B) Compilation Error","C) ConcurrentModificationException","D) Infinite Loop"],correct:2,exp:"Modifying standard Collections directly while iterating over them with a for-each loop triggers a CME."},
            {title:"Question 63: Float Precision",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(0.1 + 0.2 == 0.3);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"IEEE 754 floats cannot represent 0.1 and 0.2 perfectly. Their sum is 0.30000000000000004, which does not equal 0.3."},
            {title:"Question 64: Map Put Returns",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new HashMap<>();\n        map.put("A", 1);\n        System.out.print(map.put("A", 2));\n    }\n}`,options:["A) 1","B) 2","C) true","D) null"],correct:0,exp:"The Map.put() method returns the PREVIOUS value associated with the specified key, or null if there was no mapping."},
            {title:"Question 65: Set Object Types",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        Set<Short> set = new HashSet<>();\n        set.add((short) 1);\n        System.out.print(set.remove(1));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The remove(Object o) method requires the exact object match. 1 is an Integer, which doesn't match the Short (short)1 in the set."},
            {title:"Question 66: Interface Default Conflicts",tag:"Interfaces",code:`interface A { default void show() {} }\ninterface B { default void show() {} }\nclass C implements A, B {}\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Runtime Error","C) Compilation Error","D) Prints nothing"],correct:2,exp:"Implementing multiple interfaces with matching default methods causes a compilation error unless overridden in the class."},
            {title:"Question 67: Interface Variable Shadowing",tag:"Interfaces",code:`interface A { int X = 1; }\nclass B implements A { int X = 2; }\npublic class Main {\n    public static void main(String[] args) { System.out.print(new B().X); }\n}`,options:["A) 1","B) 2","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Interface variables are static final, but a class implementing the interface can declare its own variable to shadow it."},
            {title:"Question 68: Try With Resources Order",tag:"Exceptions",code:`class R implements AutoCloseable { \n    public void close() { System.out.print("C"); } \n}\npublic class Main {\n    public static void main(String[] args) {\n        try (R r1 = new R(); R r2 = new R()) { }\n    }\n}`,options:["A) CC","B) Compilation Error","C) No Output","D) Exception"],correct:0,exp:"Try-with-resources automatically closes resources. They are closed in the exact REVERSE order of their creation."},
            {title:"Question 69: Covariance Trap",tag:"Generics",code:`public class Main {\n    public static void main(String[] args) {\n        List<Number> list = new ArrayList<Integer>();\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"While arrays are covariant (Number[] = Integer[]), generic collections are strictly invariant to ensure type safety."},
            {title:"Question 70: Type Erasure Match",tag:"Generics",code:`public class Main {\n    public static void main(String[] args) {\n        Class c1 = new ArrayList<String>().getClass();\n        Class c2 = new ArrayList<Integer>().getClass();\n        System.out.print(c1 == c2);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Due to Type Erasure, generic type information is discarded at runtime. Both objects resolve to the raw ArrayList.class."},
            {title:"Question 71: Throwing Broader Exceptions",tag:"Polymorphism",code:`class P { void run() throws java.io.IOException {} }\nclass C extends P { void run() throws Exception {} }\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Deprecation Warning"],correct:1,exp:"An overridden method cannot throw a broader/checked exception than its parent method. Exception is broader than IOException."},
            {title:"Question 72: Covariant Return Types",tag:"Polymorphism",code:`class P { Object get() { return null; } }\nclass C extends P { String get() { return "A"; } }\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Java supports covariant return types. An overridden method can return a more specific subclass (String instead of Object)."},
            {title:"Question 73: Private Member Access",tag:"Encapsulation",code:`class A { private int x=1; void test(A a) { System.out.print(a.x); } }\npublic class Main {\n    public static void main(String[] args) { new A().test(new A()); }\n}`,options:["A) 1","B) Compilation Error","C) Runtime Error","D) IllegalAccessException"],correct:0,exp:"Private access is enforced at the CLASS level, not the instance level. An object can access private fields of another object of the same class."},
            {title:"Question 74: Main Thread Daemon",tag:"Multithreading",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Thread.currentThread().isDaemon());\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The main thread in Java is a non-daemon (user) thread by default."},
            {title:"Question 75: Stream Laziness",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.stream.Stream.of(1).map(i -> { System.out.print("M"); return i; });\n    }\n}`,options:["A) M","B) Prints nothing","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Intermediate stream operations (like map) are lazy. Without a terminal operation (like collect or forEach), they don't execute at all."},
            {title:"Question 76: Effectively Final",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        int x = 1; x++;\n        Runnable r = () -> System.out.print(x);\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Prints 2"],correct:1,exp:"Variables used inside a lambda must be final or effectively final. Modifying 'x' removes its effectively final status."},
            {title:"Question 77: Octal Literals",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        int x = 010;\n        System.out.print(x);\n    }\n}`,options:["A) 10","B) 8","C) 0","D) Compilation Error"],correct:1,exp:"In Java, an integer literal starting with 0 is interpreted as an octal (base-8) number. 010 equals 8 in decimal."},
            {title:"Question 78: ParseInt Octal Trap",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Integer.parseInt("010"));\n    }\n}`,options:["A) 10","B) 8","C) Compilation Error","D) NumberFormatException"],correct:0,exp:"Unlike code literals, parseInt assumes base-10 by default and completely ignores leading zeros. It parses as 10."},
            {title:"Question 79: Hex Literals",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        int x = 0x10;\n        System.out.print(x);\n    }\n}`,options:["A) 10","B) 16","C) 8","D) Compilation Error"],correct:1,exp:"The 0x prefix denotes hexadecimal (base-16). 0x10 equals 16 in decimal."},
            {title:"Question 80: The Long Overflow",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        long l = 1000 * 60 * 60 * 24 * 365;\n        System.out.print(l > 0);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"All math operations happen as ints before assignment. The resulting value overflows the 32-bit int limit and wraps to a negative, THEN assigns to long."},
            {title:"Question 81: Boxed Compile Error",tag:"Wrappers",code:`public class Main {\n    public static void main(String[] args) {\n        Long l = 100;\n        System.out.print(l);\n    }\n}`,options:["A) 100","B) Compilation Error","C) Runtime Error","D) ClassCastException"],correct:1,exp:"The literal 100 is an int. Auto-boxing converts int to Integer, but you cannot assign an Integer to a Long reference. It needs to be 100L."},
            {title:"Question 82: Boolean Spaces",tag:"Wrappers",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Boolean.parseBoolean("True "));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Exception"],correct:1,exp:"parseBoolean strictly checks against 'true' ignoring case. Any whitespace causes the check to fail, returning false."},
            {title:"Question 83: BigDecimal Scale",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        java.math.BigDecimal b1 = new java.math.BigDecimal("0.1");\n        java.math.BigDecimal b2 = new java.math.BigDecimal("0.10");\n        System.out.print(b1.equals(b2));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"BigDecimal.equals compares both value AND scale (number of decimal places). Since the scales differ (1 vs 2), it is false."},
            {title:"Question 84: BigDecimal Compare",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        java.math.BigDecimal b1 = new java.math.BigDecimal("0.1");\n        java.math.BigDecimal b2 = new java.math.BigDecimal("0.10");\n        System.out.print(b1.compareTo(b2));\n    }\n}`,options:["A) 0","B) 1","C) -1","D) false"],correct:0,exp:"Unlike equals, compareTo only considers numerical value and ignores scale. They are mathematically equal, returning 0."},
            {title:"Question 85: Enum Interface",tag:"Enums",code:`interface I {}\nenum Colors implements I { RED, BLUE }\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning"],correct:0,exp:"Enums implicitly extend java.lang.Enum so they cannot extend classes, but they are fully allowed to implement interfaces."},
            {title:"Question 86: Throw Null",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        RuntimeException e = null; throw e;\n    }\n}`,options:["A) NullPointerException","B) Compilation Error","C) Code exits normally","D) RuntimeException"],correct:0,exp:"Attempting to throw a null reference causes the JVM to immediately throw a NullPointerException."},
            {title:"Question 87: Labeled Break",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        lbl: for(int i=0; i<3; i++) { if(i==1) break lbl; System.out.print(i); }\n    }\n}`,options:["A) 0","B) 01","C) 012","D) Compilation Error"],correct:0,exp:"Labels allow breaking out of loops entirely. It prints 0, then when i reaches 1, it breaks the outer label entirely."},
            {title:"Question 88: Precision Loop",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        for(double i=0; i!=10; i+=0.1) {} \n    }\n}`,options:["A) Loop runs 100 times","B) Compilation Error","C) Infinite Loop","D) Runtime Error"],correct:2,exp:"Because 0.1 cannot be represented perfectly in float math, i will never EXACTLY equal 10.0, resulting in an infinite loop."},
            {title:"Question 89: Null Concatenation",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(null + "null");\n    }\n}`,options:["A) nullnull","B) Compilation Error","C) NullPointerException","D) null"],correct:0,exp:"Java's string concatenation operator converts the null reference literal to the string 'null' before appending."},
            {title:"Question 90: Array is Object",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        Object obj = new int[] {1, 2, 3};\n        System.out.print(obj instanceof Object);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) ClassCastException"],correct:0,exp:"In Java, arrays (even arrays of primitives) are fully-fledged Objects and inherit from java.lang.Object."},
            {title:"Question 91: Array Equality",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a = {1}; int[] b = {1};\n        System.out.print(a.equals(b));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Arrays do not override Object.equals(). It falls back to memory reference comparison (==), requiring Arrays.equals() instead."},
            {title:"Question 92: Math Max",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Math.max(Integer.MIN_VALUE, Integer.MIN_VALUE));\n    }\n}`,options:["A) 2147483647","B) -2147483648","C) 0","D) Compilation Error"],correct:1,exp:"Math.max compares the two values. If both are the lowest possible integer value, it simply returns that value (-2147483648)."},
            {title:"Question 93: Wrapper Classes by Value",tag:"Wrappers",code:`public class Main {\n    static void f(Integer i) { i++; }\n    public static void main(String[] args) { Integer x = 5; f(x); System.out.print(x); }\n}`,options:["A) 5","B) 6","C) Compilation Error","D) NPE"],correct:0,exp:"Wrappers are immutable. i++ unboxes, adds, and boxes to a completely new Integer object locally, leaving x untouched."},
            {title:"Question 94: Set.of Duplicates",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(java.util.Set.of(1, 1).size());\n    }\n}`,options:["A) 1","B) 2","C) Compilation Error","D) IllegalArgumentException"],correct:3,exp:"The Set.of() factory method strictly forbids duplicate elements and immediately throws an IllegalArgumentException."},
            {title:"Question 95: Void Map Value",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.Map.of("a", 1, "a", 2);\n    }\n}`,options:["A) Runs successfully","B) Compilation Error","C) IllegalArgumentException","D) NullPointerException"],correct:2,exp:"Similar to Set.of, Map.of() rejects duplicate keys and throws an IllegalArgumentException immediately."},
            {title:"Question 96: Var with Null",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        var v = null;\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:1,exp:"The 'var' keyword relies on type inference. It cannot infer a type from 'null', causing a compilation error."},
            {title:"Question 97: Invalid Leap Year",tag:"Time",code:`public class Main {\n    public static void main(String[] args) {\n        java.time.LocalDate.of(2023, 2, 29);\n    }\n}`,options:["A) NullPointerException","B) DateTimeException","C) Compilation Error","D) Creates March 1st"],correct:1,exp:"2023 is not a leap year. The strict java.time API validates this and throws a DateTimeException."},
            {title:"Question 98: Pooled String Identity",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) { System.out.print("a" == "a"); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"String literals are pooled. Both instances of the literal point to the exact same reference in memory."},
            {title:"Question 99: Overloading Ambiguity",tag:"Overloading",code:`public class Main {\n    static void f(String s) {} static void f(StringBuffer s) {}\n    public static void main(String[] args) { f(null); }\n}`,options:["A) Compiles fine","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:1,exp:"Neither String nor StringBuffer inherits from the other. The compiler cannot determine which specific method to call for null."},
            {title:"Question 100: XOR Swap Logic",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        boolean b1 = true, b2 = false;\n        System.out.print(b1 ^= b2);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The bitwise XOR assignment operator works on booleans. true XOR false is true, which is assigned back to b1."},
            {title:"Question 101: Nested Interfaces",tag:"Interfaces",code:`class Outer { interface Inner {} }\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interfaces defined inside classes are perfectly legal and are implicitly static."},
            {title:"Question 102: Volatile Keyword",tag:"Concurrency",code:`public class Main {\n    volatile int count = 0;\n    void inc() { count++; }\n}`,options:["A) count is thread-safe","B) count++ is not atomic","C) Compilation Error","D) Memory leak"],correct:1,exp:"volatile guarantees visibility between threads, but operations like count++ (read-modify-write) are still NOT atomic."},
            {title:"Question 103: Garbage Collection",tag:"Memory",code:`public class Main {\n    public static void main(String[] args) { System.gc(); }\n}`,options:["A) Forcefully runs GC","B) Suggests GC to run","C) Compilation Error","D) Clears RAM"],correct:1,exp:"System.gc() is only a hint/suggestion to the JVM. It makes no strict guarantee that garbage collection will occur immediately."},
            {title:"Question 104: Multiple Classes",tag:"Syntax",code:`class A {} class B extends A, Object {}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning"],correct:1,exp:"Java does not support multiple inheritance of classes. You cannot use a comma-separated list of classes with 'extends'."},
            {title:"Question 105: Array Index Increment",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a = {10, 20}; int i = 0;\n        System.out.print(a[++i]);\n    }\n}`,options:["A) 10","B) 20","C) Compilation Error","D) ArrayIndexOutOfBounds"],correct:1,exp:"Pre-increment increases i to 1 before the array access. a[1] is 20."},
            {title:"Question 106: Primitive Null Cast",tag:"Types",code:`public class Main {\n    public static void main(String[] args) { int x = (int) null; }\n}`,options:["A) Sets to 0","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:1,exp:"Null can be cast to any reference/object type, but it cannot be cast to a primitive type like int."},
            {title:"Question 107: Collections Empty Mod",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.Collections.emptyList().add(1);\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) UnsupportedOperationException","D) NullPointerException"],correct:2,exp:"Collections.emptyList() returns a strictly immutable empty list wrapper. Attempting to modify it throws an exception."},
            {title:"Question 108: Static Block Error",tag:"Exceptions",code:`class A { static { int x = 1/0; } }\npublic class Main {\n    public static void main(String[] args) { new A(); }\n}`,options:["A) ArithmeticException","B) ExceptionInInitializerError","C) Compilation Error","D) No output"],correct:1,exp:"An unchecked exception occurring within a static initialization block gets wrapped into an ExceptionInInitializerError."},
            {title:"Question 109: ValueOf Null Array",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        char[] c = null; System.out.print(String.valueOf(c));\n    }\n}`,options:["A) null","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:2,exp:"Extremely tricky: valueOf(char[]) does not handle nulls safely like valueOf(Object) does. It throws an immediate NPE."},
            {title:"Question 110: ValueOf Null Object",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        Object o = null; System.out.print(String.valueOf(o));\n    }\n}`,options:["A) null","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:0,exp:"Unlike the char[] overload, String.valueOf(Object) contains a safe null check and returns the literal string 'null'."},
            {title:"Question 111: Repeat Zero",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) { System.out.print("A".repeat(0)); }\n}`,options:["A) A","B) Compilation Error","C) Prints nothing (empty)","D) IllegalArgumentException"],correct:2,exp:"The repeat method allows passing 0. It simply returns an empty string."},
            {title:"Question 112: Infinity Equality",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(1.0/0.0 == 2.0/0.0);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) ArithmeticException"],correct:0,exp:"Both resolve to Double.POSITIVE_INFINITY. In IEEE 754 float math, Infinity == Infinity is always true."},
            {title:"Question 113: Cross Infinity",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Double.POSITIVE_INFINITY == Float.POSITIVE_INFINITY);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) ClassCastException"],correct:0,exp:"The Float infinity is promoted to Double. Both represent mathematically equivalent infinities, resulting in true."},
            {title:"Question 114: Generic Number Cast",tag:"Generics",code:`public class Main {\n    public static void main(String[] args) {\n        Number n = 1.0;\n        Integer i = (Integer) n;\n    }\n}`,options:["A) Works fine","B) Compilation Error","C) ClassCastException","D) Runtime Error"],correct:2,exp:"1.0 is autoboxed as a Double. At runtime, attempting to cast a Double object to an Integer triggers a ClassCastException."},
            {title:"Question 115: Catching Errors",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        try { throw new Error(); } catch (Exception e) {}\n    }\n}`,options:["A) Caught successfully","B) Compilation Error","C) Crashes (Error unhandled)","D) Warning"],correct:2,exp:"Errors are not Exceptions. They both extend Throwable, but catch(Exception) will not catch an Error."},
            {title:"Question 116: Thread Yield",tag:"Multithreading",code:`public class Main {\n    public static void main(String[] args) { Thread.yield(); }\n}`,options:["A) Sleep for 1ms","B) Compilation Error","C) Suggests CPU switch","D) Stops thread"],correct:2,exp:"Thread.yield() is a hint to the scheduler that the current thread is willing to yield its current use of a processor."},
            {title:"Question 117: String isEmpty",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) { System.out.print(" ".isEmpty()); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"isEmpty() only returns true if length is exactly 0. A space character has length 1. (Use isBlank() to check for whitespace)."},
            {title:"Question 118: Object Clone",tag:"Object",code:`public class Main {\n    public static void main(String[] args) throws Exception {\n        new Object().clone();\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) CloneNotSupportedException","D) IllegalAccess"],correct:1,exp:"The clone() method in Object is protected. It cannot be called directly from outside the class unless overridden."},
            {title:"Question 119: Boolean Array Default",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        boolean[] b = new boolean[1]; System.out.print(b[0]);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) null"],correct:1,exp:"The default value for boolean elements in an array is always false."},
            {title:"Question 120: Method Reference Target",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.function.Supplier<String> s = Object::toString;\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) ClassCastException"],correct:1,exp:"Object::toString is an instance method. Supplier takes no arguments, leaving the method reference without a target object to call toString on."},
            {title:"Question 121: Instance Method Ref",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.function.Function<Object, String> f = Object::toString;\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) ClassCastException"],correct:0,exp:"Unlike the Supplier, the Function provides the target Object as the first argument, so Object::toString maps perfectly."},
            {title:"Question 122: Transient Fields",tag:"Serialization",code:`class A implements java.io.Serializable { transient int x = 5; }`,options:["A) Serialized as 5","B) Serialized as 0","C) Compilation Error","D) Ignored completely"],correct:1,exp:"Transient fields are excluded from standard serialization. Upon deserialization, primitives default to 0 (or false/null)."},
            {title:"Question 123: IntStream Range",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(java.util.stream.IntStream.range(1, 3).sum());\n    }\n}`,options:["A) 6","B) 3","C) 4","D) Compilation Error"],correct:1,exp:"IntStream.range(start, end) is EXCLUSIVE of the end value. It streams 1 and 2, summing to 3."},
            {title:"Question 124: IntStream Range Closed",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(java.util.stream.IntStream.rangeClosed(1, 3).sum());\n    }\n}`,options:["A) 6","B) 3","C) 4","D) Compilation Error"],correct:0,exp:"rangeClosed is INCLUSIVE. It streams 1, 2, and 3, summing to 6."},
            {title:"Question 125: Record Immutability",tag:"Records",code:`record R(int x) {}\npublic class Main {\n    public static void main(String[] args) { R r = new R(1); r.x = 2; }\n}`,options:["A) Prints nothing","B) Compilation Error","C) Runtime Error","D) Allowed in Java 14+"],correct:1,exp:"Record components are implicitly final. Attempting to modify 'x' triggers a compilation error."},
            {title:"Question 126: Null String Switch",tag:"Switch",code:`public class Main {\n    public static void main(String[] args) {\n        String s = null; switch(s) { default: System.out.print("D"); }\n    }\n}`,options:["A) D","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:2,exp:"Even if a default branch exists, switching on a null string immediately throws an NPE during evaluation."},
            {title:"Question 127: Labeled Continue",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        l: for(int i=0;i<2;i++) { for(int j=0;j<2;j++) { continue l; } System.out.print("X"); }\n    }\n}`,options:["A) XX","B) Compilation Error","C) Prints nothing","D) XXXX"],correct:2,exp:"The inner loop continually jumps back to the outer loop 'l' before ever reaching the print statement. It prints nothing."},
            {title:"Question 128: Protected Clone",tag:"OOP",code:`class A { protected Object clone() throws Exception { return super.clone(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Needs interface"],correct:0,exp:"Overriding protected methods without implementing Cloneable compiles fine, but executing it will throw CloneNotSupportedException."},
            {title:"Question 129: Uninitialized Array Print",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a = new int[2]; System.out.print(a);\n    }\n}`,options:["A) [0, 0]","B) Memory address","C) Compilation Error","D) null"],correct:1,exp:"Unless it's a char array, passing an array directly to System.out.print prints its type signature and memory hashcode."},
            {title:"Question 130: Stream Count",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(java.util.stream.Stream.of(1, 2, null).count());\n    }\n}`,options:["A) 2","B) 3","C) NullPointerException","D) Compilation Error"],correct:1,exp:"Stream.count() returns the total number of elements. Null elements are completely valid and are included in the count."},
            {title:"Question 131: FlatMap Type",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.stream.Stream.of(1).flatMap(i -> i);\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Returns Stream"],correct:1,exp:"flatMap strictly requires the lambda to return a Stream, not the element itself. Returning 'i' causes a compilation error."},
            {title:"Question 132: Integer Parse Sign",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Integer.parseInt("+10"));\n    }\n}`,options:["A) 10","B) Compilation Error","C) NumberFormatException","D) +10"],correct:0,exp:"parseInt legally accepts an explicit '+' or '-' sign prefix."},
            {title:"Question 133: Var in Lambda",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.function.Consumer<String> c = (var x) -> {};\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Allowed only in Java 8"],correct:0,exp:"Since Java 11, the 'var' keyword is perfectly legal inside implicitly typed lambda expressions."},
            {title:"Question 134: Mixed Var Lambda",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.function.BiConsumer<String, String> b = (var x, y) -> {};\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Allowed in Java 11+"],correct:1,exp:"You cannot mix 'var' and implicitly typed parameters in a lambda. It must be (var x, var y) or (x, y)."},
            {title:"Question 135: Double Min Value",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Double.MIN_VALUE > 0);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Unlike Integer, Double.MIN_VALUE is the smallest positive fraction greater than zero, so it is strictly > 0."},
            {title:"Question 136: Float and Double Equality",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(0.1f == 0.1d);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Due to binary precision limits, the float 0.1f expands differently than the double 0.1d. They are not strictly equal."},
            {title:"Question 137: Whole Number Float",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(1.0f == 1.0d);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Unlike fractions like 0.1, whole numbers like 1.0 can be represented perfectly in binary. The float and double match exactly."},
            {title:"Question 138: Instanceof with Interface",tag:"Types",code:`interface I {}\npublic class Main {\n    public static void main(String[] args) {\n        System.out.print("A" instanceof I);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The compiler allows instanceof checks against interfaces because a subclass could potentially implement it, but it yields false at runtime."},
            {title:"Question 139: Yield in Switch",tag:"Switch",code:`public class Main {\n    public static void main(String[] args) {\n        int x = switch(1) { default -> { yield 2; } };\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Syntax Error"],correct:0,exp:"In modern Java switch expressions, the 'yield' keyword is used to return a value from a block statement."},
            {title:"Question 140: Substring Bounds",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print("A".substring(1, 1));\n    }\n}`,options:["A) A","B) Prints nothing","C) StringIndexOutOfBounds","D) Compilation Error"],correct:1,exp:"substring(begin, end) is inclusive-exclusive. An empty range like (1, 1) is valid and safely returns an empty string."},
            {title:"Question 141: Modulo on Doubles",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(5.5 % 2);\n    }\n}`,options:["A) 1.5","B) 1","C) 1.0","D) Compilation Error"],correct:0,exp:"Unlike some languages, Java fully supports the modulo operator % on floating-point numbers."},
            {title:"Question 142: Arrays AsList Change",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        String[] arr = {"A"}; java.util.List<String> l = java.util.Arrays.asList(arr);\n        l.set(0, "B"); System.out.print(arr[0]);\n    }\n}`,options:["A) A","B) B","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Arrays.asList returns a view backed strictly by the original array. Modifying the list immediately mutates the underlying array."},
            {title:"Question 143: CopyOf Change",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.List<String> l1 = new ArrayList<>(java.util.Arrays.asList("A"));\n        java.util.List<String> l2 = java.util.List.copyOf(l1);\n        l1.set(0, "B"); System.out.print(l2.get(0));\n    }\n}`,options:["A) A","B) B","C) Compilation Error","D) Runtime Error"],correct:0,exp:"List.copyOf() makes a truly independent, unmodifiable snapshot. Future changes to the original list do NOT affect it."},
            {title:"Question 144: Null String Value",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        String s = null; System.out.print(s + 1);\n    }\n}`,options:["A) null1","B) 1","C) NullPointerException","D) Compilation Error"],correct:0,exp:"Java string concatenation automatically converts null references to the text 'null'."},
            {title:"Question 145: Array Type Assignment",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a1 = {1}; Object[] a2 = a1;\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) ClassCastException"],correct:1,exp:"While Integer[] is an Object[], an array of primitives (int[]) is NOT an Object[]. It is just an Object."},
            {title:"Question 146: Enum Ordinal",tag:"Enums",code:`enum E { A, B } \npublic class Main {\n    public static void main(String[] args) { System.out.print(E.B.ordinal()); }\n}`,options:["A) 0","B) 1","C) 2","D) Compilation Error"],correct:1,exp:"The ordinal() method returns the 0-based index of the enum constant. B is the second element, so it returns 1."},
            {title:"Question 147: Transient Constructor",tag:"Constructors",code:`public class Main {\n    transient Main() {}\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Ignored"],correct:1,exp:"The 'transient' keyword can only be applied to fields/variables. It cannot be applied to methods, classes, or constructors."},
            {title:"Question 148: Math Pow Type",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        int x = Math.pow(2, 3);\n    }\n}`,options:["A) 8","B) Compilation Error","C) Runtime Error","D) 0"],correct:1,exp:"Math.pow() always returns a double. You cannot implicitly assign a double to an int without an explicit cast."},
            {title:"Question 149: Wait Outside Sync",tag:"Concurrency",code:`public class Main {\n    public static void main(String[] args) throws Exception {\n        new Object().wait();\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) IllegalMonitorStateException","D) Infinite wait"],correct:2,exp:"Calling wait() requires the thread to hold the monitor lock (via synchronized block). Otherwise, it throws IllegalMonitorStateException."},
            {title:"Question 150: Finalizer Deprecation",tag:"Memory",code:`public class Main {\n    @Override protected void finalize() {}\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Deprecation Warning"],correct:3,exp:"The finalize() method has been officially deprecated since Java 9 and marked for removal due to unpredictable performance constraints."},

            // Part 3: 151 - 250 (Deep OOP Concepts)
            {title:"Question 151: Constructor Chaining Execution",tag:"Constructors",code:`class A { A() { System.out.print("A"); } }\nclass B extends A { B() { System.out.print("B"); } }\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) A","B) B","C) AB","D) BA"],correct:2,exp:"When a child class is instantiated, it implicitly calls the parent's no-argument constructor first (super()) before executing its own."},
            {title:"Question 152: Implicit Super Failure",tag:"Constructors",code:`class A { A(int x) {} }\nclass B extends A { B() {} }\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Prints nothing"],correct:1,exp:"Class B's default constructor implicitly calls super(). But class A has no default constructor (only parameterized), causing a compile error."},
            {title:"Question 153: Super in Try-Catch",tag:"Constructors",code:`class A { A() throws Exception {} }\nclass B extends A { B() { try { super(); } catch(Exception e) {} } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"The super() constructor call must be the absolute first statement in a constructor. It cannot be wrapped inside a try-catch block."},
            {title:"Question 154: Instance Variable Hiding",tag:"OOP",code:`class P { int x = 10; }\nclass C extends P { int x = 20; }\npublic class Main { public static void main(String[] args) { P p = new C(); System.out.print(p.x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Variables are not polymorphic. They are hidden, not overridden. The reference type (P) dictates which variable is accessed at compile time."},
            {title:"Question 155: Static Method Hiding",tag:"OOP",code:`class P { static void m() { System.out.print("P"); } }\nclass C extends P { static void m() { System.out.print("C"); } }\npublic class Main { public static void main(String[] args) { P p = new C(); p.m(); } }`,options:["A) P","B) C","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Static methods belong to the class and are hidden, not dynamically overridden. The call is resolved at compile time based on the reference type (P)."},
            {title:"Question 156: Private Method Override",tag:"Encapsulation",code:`class P { private void m() { System.out.print("P"); } }\nclass C extends P { public void m() { System.out.print("C"); } }\npublic class Main { public static void main(String[] args) { P p = new C(); p.m(); } }`,options:["A) P","B) C","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Compilation Error. The private method in the parent class is not visible to the Main class, so p.m() cannot be invoked."},
            {title:"Question 157: Final Method Override",tag:"Polymorphism",code:`class A { final void f() {} }\nclass B extends A { void f() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"The final keyword on a method explicitly prevents any subclass from overriding it."},
            {title:"Question 158: Ambiguous Interface Constants",tag:"Interfaces",code:`interface I1 { int X = 10; }\ninterface I2 { int X = 20; }\nclass C implements I1, I2 { public void print() { System.out.print(X); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Implementing multiple interfaces with the same constant variable creates ambiguity. You must specify it as I1.X or I2.X."},
            {title:"Question 159: Abstract Constructor",tag:"Abstraction",code:`abstract class A { A() { System.out.print("A"); } }\nclass B extends A {}\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) Prints nothing","B) Compilation Error","C) Runtime Error","D) A"],correct:3,exp:"Abstract classes cannot be instantiated directly, but they can have valid constructors that are invoked by subclasses during instantiation."},
            {title:"Question 160: This and Super Together",tag:"Constructors",code:`class A { A() { this(1); super(); } A(int x) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Infinite Loop"],correct:1,exp:"Both this() and super() mandate being the absolute first statement in a constructor. Therefore, they can never be used together in the same constructor block."},
            {title:"Question 161: Instanceof Subclass",tag:"OOP",code:`class A {}\nclass B extends A {}\nclass C extends B {}\npublic class Main { public static void main(String[] args) { A a = new C(); System.out.print(a instanceof B); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The actual object is of type C. Since C extends B, the object IS-A B. instanceof resolves to true."},
            {title:"Question 162: Covariant Primitive Returns",tag:"Polymorphism",code:`class P { Object get() { return null; } }\nclass C extends P { int get() { return 1; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Covariant return types only work for reference (object) types. You cannot override an Object return type with a primitive like int."},
            {title:"Question 163: Covariant Array Returns",tag:"Polymorphism",code:`class P { Number[] get() { return null; } }\nclass C extends P { Integer[] get() { return null; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Array types are covariant. Since Integer extends Number, Integer[] is a valid covariant return type for Number[]."},
            {title:"Question 164: Exception Override Check",tag:"Polymorphism",code:`class P { void run() throws RuntimeException {} }\nclass C extends P { void run() throws Exception {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"An overriding method cannot throw a broader or new checked exception (Exception) than the parent method (RuntimeException)."},
            {title:"Question 165: Exception Override Uncheck",tag:"Polymorphism",code:`class P { void run() throws java.io.IOException {} }\nclass C extends P { void run() throws RuntimeException {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Overriding methods are completely free to throw any unchecked (Runtime) exceptions, regardless of what the parent throws."},
            {title:"Question 166: The Runtime This",tag:"Constructors",code:`class A { A() { System.out.print(this.getClass().getSimpleName()); } }\nclass B extends A {}\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) A","B) B","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Even when invoked inside a parent constructor, the 'this' keyword always points to the actual runtime object being constructed (B)."},
            {title:"Question 167: Constructor Polymorphism Trap",tag:"OOP",code:`class P { P() { m(); } void m() { System.out.print("P"); } }\nclass C extends P { int x = 5; void m() { System.out.print(x); } }\npublic class Main { public static void main(String[] args) { new C(); } }`,options:["A) 5","B) P","C) 0","D) Compilation Error"],correct:2,exp:"P's constructor calls the overridden m() in C BEFORE C's instance variables are initialized, so it prints the default value of x (0)."},
            {title:"Question 168: Overload Widen vs Box",tag:"Overloading",code:`public class Main {\n    void f(long l) { System.out.print("L"); }\n    void f(Integer i) { System.out.print("I"); }\n    public static void main(String[] args) { new Main().f(10); }\n}`,options:["A) L","B) I","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Java prefers widening a primitive (int to long) over autoboxing (int to Integer) when resolving method overloads."},
            {title:"Question 169: Overload Box vs Vararg",tag:"Overloading",code:`public class Main {\n    void f(int... i) { System.out.print("V"); }\n    void f(Integer i) { System.out.print("W"); }\n    public static void main(String[] args) { new Main().f(10); }\n}`,options:["A) V","B) W","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Java resolves overloads by preferring autoboxing (int to Integer) over variable arguments (int...)."},
            {title:"Question 170: Overload Vararg vs Array",tag:"Overriding",code:`class P { void m(int... x) { System.out.print("P"); } }\nclass C extends P { void m(int[] x) { System.out.print("C"); } }\npublic class Main { public static void main(String[] args) { P p = new C(); p.m(1); } }`,options:["A) P","B) C","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Varargs (int...) and arrays (int[]) are compiled to the exact same signature. Therefore, C successfully overrides P's method."},
            {title:"Question 171: Cast Parent to Child",tag:"OOP",code:`class P {}\nclass C extends P {}\npublic class Main { public static void main(String[] args) { P p = new P(); C c = (C) p; } }`,options:["A) Compiles fine, runs fine","B) Compilation Error","C) ClassCastException","D) NullPointerException"],correct:2,exp:"You cannot downcast a parent object instance to a child reference. The object in memory is strictly a P, not a C."},
            {title:"Question 172: Overload Equals",tag:"OOP",code:`class A { public boolean equals(A obj) { return true; } }`,options:["A) Overrides Object.equals","B) Overloads Object.equals","C) Compilation Error","D) Runtime Error"],correct:1,exp:"To override, it MUST take an Object parameter: equals(Object obj). Taking type A means it simply overloads the method."},
            {title:"Question 173: Instanceof Null",tag:"OOP",code:`public class Main { public static void main(String[] args) { String s = null; System.out.print(s instanceof String); } }`,options:["A) true","B) false","C) Compilation Error","D) NullPointerException"],correct:1,exp:"The instanceof operator safely checks nulls. Null is not an instance of any class, so it reliably returns false."},
            {title:"Question 174: Null Instanceof Interface",tag:"Interfaces",code:`interface I {}\npublic class Main { public static void main(String[] args) { Main m = null; System.out.print(m instanceof I); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Same as class checks, instanceof gracefully returns false when checking a null reference against an interface."},
            {title:"Question 175: Class Instanceof Interface",tag:"Interfaces",code:`class A {}\ninterface I {}\npublic class Main { public static void main(String[] args) { A a = new A(); System.out.print(a instanceof I); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Compiles fine and returns false. The compiler allows it because a future subclass of A could potentially implement I at runtime."},
            {title:"Question 176: Unrelated Instanceof",tag:"OOP",code:`class A {}\nclass B {}\npublic class Main { public static void main(String[] args) { A a = new A(); System.out.print(a instanceof B); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Compilation Error. The compiler strictly knows A and B are completely unrelated classes in the hierarchy and prevents the check."},
            {title:"Question 177: Anonymous Abstract",tag:"Abstraction",code:`abstract class A {}\npublic class Main { public static void main(String[] args) { A a = new A() {}; System.out.print(a.getClass().getName().contains("$")); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The curly braces {} instantiate an anonymous inner subclass of the abstract class, which gets a generated name containing a $."},
            {title:"Question 178: Abstract Interface Impl",tag:"Abstraction",code:`interface I { void m1(); void m2(); }\nabstract class A implements I { public void m1() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Needs m2() implemented"],correct:0,exp:"Abstract classes implementing interfaces do NOT need to implement all interface methods. The unimplemented ones remain abstract."},
            {title:"Question 179: Interface Variable Mod",tag:"Interfaces",code:`interface I { int x = 10; }\npublic class Main implements I { public static void main(String[] args) { I.x = 20; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"All variables declared inside an interface are implicitly public, static, and final. They cannot be reassigned."},
            {title:"Question 180: Default Method Super",tag:"Interfaces",code:`interface I { default void m() { System.out.print("I"); } }\nclass C implements I { public void m() { I.super.m(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"I.super.m() is the correct valid syntax for a class to invoke a default method from an interface it implements."},
            {title:"Question 181: Static Inner Class",tag:"Inner Classes",code:`class Outer { static class Inner {} }\npublic class Main { public static void main(String[] args) { Outer.Inner i = new Outer.Inner(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Needs outer instance"],correct:0,exp:"Static inner classes do not require an instance of the outer class to be instantiated."},
            {title:"Question 182: Non-Static Inner Class",tag:"Inner Classes",code:`class Outer { class Inner {} }\npublic class Main { public static void main(String[] args) { Outer.Inner i = new Outer().new Inner(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Non-static inner classes require an instance of the outer class, instantiated using outerObject.new Inner()."},
            {title:"Question 183: Inner Access Outer Private",tag:"Encapsulation",code:`class Outer { private int x = 10; class Inner { void get() { System.out.print(x); } } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Inner classes have full access to all members of the outer class, including private variables."},
            {title:"Question 184: Outer Access Inner Private",tag:"Encapsulation",code:`class Outer { class Inner { private int x = 10; } void get() { System.out.print(new Inner().x); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interestingly, outer classes ALSO have direct access to the private members of their inner classes via an instance."},
            {title:"Question 185: Local Class Final Var",tag:"Inner Classes",code:`public class Main { public static void main(String[] args) { int x = 10; class Local { void print() { System.out.print(x); } } x = 20; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Prints 20"],correct:1,exp:"Local variables accessed by local inner classes must be final or 'effectively final'. Changing x to 20 violates this."},
            {title:"Question 186: Singleton Factory",tag:"OOP",code:`class A { private A() {} static A create() { return new A(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"This is perfectly valid and is the basis for the Singleton and Factory design patterns using private constructors."},
            {title:"Question 187: Enum Constructor Runs",tag:"Enums",code:`enum E { A, B; private E() { System.out.print("E"); } }\npublic class Main { public static void main(String[] args) { E e = E.A; } }`,options:["A) E","B) EE","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Enum constructors execute exactly once for EVERY enum constant when the enum class is loaded into memory (EE)."},
            {title:"Question 188: Enum New",tag:"Enums",code:`enum E { A }\npublic class Main { public static void main(String[] args) { E e = new E(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Enums represent a fixed set of constants. They strictly cannot be manually instantiated using the 'new' keyword."},
            {title:"Question 189: Clone super",tag:"Object",code:`class A implements Cloneable { public Object clone() { return super.clone(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Object.clone() throws the checked CloneNotSupportedException, which must be either caught or declared in the method signature."},
            {title:"Question 190: Override Expand Access",tag:"Polymorphism",code:`class P { void run() {} }\nclass C extends P { protected void run() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Overriding methods are allowed to expand (make more permissive) the access modifier (from package-private to protected)."},
            {title:"Question 191: Override Reduce Access",tag:"Polymorphism",code:`class P { protected void run() {} }\nclass C extends P { void run() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Overriding methods CANNOT reduce visibility (from protected to package-private). This causes a compilation error."},
            {title:"Question 192: Blank Final Constructor",tag:"Constructors",code:`class A { final int x; A() { x = 10; } A(int y) { } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A blank final variable must be definitely assigned in EVERY constructor. The second constructor fails to initialize x."},
            {title:"Question 193: Static Final Constructor",tag:"Constructors",code:`class A { static final int x; A() { x = 10; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Static final variables must be initialized during class loading (at declaration or in a static block), NOT in an instance constructor."},
            {title:"Question 194: Default Equals",tag:"OOP",code:`public class Main {\n    public static void main(String[] args) { Main m1 = new Main(); Main m2 = new Main(); System.out.print(m1.equals(m2)); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Unless overridden, Object's default equals() method simply compares memory addresses (==), returning false for two distinct objects."},
            {title:"Question 195: Instance Override Static",tag:"Polymorphism",code:`class P { static void m() {} }\nclass C extends P { void m() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"An instance method cannot override a static method. The compiler strictly forbids this crossover."},
            {title:"Question 196: Record Compact Constructor",tag:"Records",code:`record Point(int x, int y) { Point { if (x < 0) x = 0; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Java Records support 'compact constructors' without formal parameters to validate or adjust data before assignment."},
            {title:"Question 197: Record Field Mod",tag:"Records",code:`record Point(int x, int y) {}\npublic class Main { public static void main(String[] args) { Point p = new Point(1, 2); p.x = 3; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Record components are implicitly private and final. You cannot modify them after the record is created."},
            {title:"Question 198: Sealed Hierarchy",tag:"OOP",code:`sealed class A permits B {}\nfinal class B extends A {}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Sealed classes successfully restrict inheritance. Subclasses defined in the permits clause must be final, sealed, or non-sealed."},
            {title:"Question 199: Sealed Missing Modifier",tag:"OOP",code:`sealed class A permits B {}\nclass B extends A {}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A permitted subclass of a sealed class must explicitly declare itself as final, sealed, or non-sealed."},
            {title:"Question 200: Null instanceof Object",tag:"OOP",code:`public class Main { public static void main(String[] args) { System.out.print(null instanceof Object); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"null is not an object and does not inherit from Object. The instanceof check safely returns false."},
            {title:"Question 201: Infinite Object Recursion",tag:"Constructors",code:`class A { A a = new A(); }\npublic class Main { public static void main(String[] args) { new A(); } }`,options:["A) Compiles fine","B) Compilation Error","C) StackOverflowError","D) OutOfMemoryError"],correct:2,exp:"When an object is created, it initializes its instance variables, creating another object recursively until the call stack blows up."},
            {title:"Question 202: Static Infinite Object",tag:"Constructors",code:`class A { static A a = new A(); A() { System.out.print("A"); } }\npublic class Main { public static void main(String[] args) { new A(); } }`,options:["A) A","B) AA","C) Compilation Error","D) StackOverflowError"],correct:1,exp:"The static variable initializes exactly once when the class loads (prints A). Then the 'new A()' in main prints the second A."},
            {title:"Question 203: Chained Constructor Super",tag:"Constructors",code:`class P { P(int x) {} }\nclass C extends P { C() { super(10); } C(int x) { this(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"This is valid constructor chaining. The int constructor delegates to the no-arg constructor, which delegates to the parent."},
            {title:"Question 204: Interface Return Conflict",tag:"Interfaces",code:`interface I1 { void run(); }\ninterface I2 { int run(); }\nclass C implements I1, I2 { public void run() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A class cannot implement two interfaces that declare the same method name with incompatible return types."},
            {title:"Question 205: Throw Omission Override",tag:"Polymorphism",code:`class A { void m() throws RuntimeException {} }\nclass B extends A { void m() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Overriding methods are completely permitted to omit (not throw) any exceptions declared by the parent method."},
            {title:"Question 206: Abstract Redeclare Abstract",tag:"Abstraction",code:`abstract class A { abstract void m(); }\nabstract class B extends A { abstract void m(); }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Abstract classes can legally redeclare an abstract method from a parent class without implementing it."},
            {title:"Question 207: Interface Impl Mod Var",tag:"Interfaces",code:`interface I { int x = 10; }\nclass A implements I { void m() { x = 20; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Variables inherited from interfaces are implicitly public static final and cannot be modified."},
            {title:"Question 208: Overload Reference Type",tag:"Overloading",code:`class A { public void m(Object o) { System.out.print("O"); } public void m(String s) { System.out.print("S"); } }\npublic class Main { public static void main(String[] args) { A a = new A(); Object obj = "Hello"; a.m(obj); } }`,options:["A) O","B) S","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Method overloading is resolved statically at compile time based strictly on the reference type (Object), not the runtime type."},
            {title:"Question 209: Override Runtime Type",tag:"Polymorphism",code:`class P { void run() { System.out.print("P"); } }\nclass C extends P { void run() { System.out.print("C"); } }\npublic class Main { public static void main(String[] args) { P p = new C(); p.run(); } }`,options:["A) P","B) C","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Method overriding is resolved dynamically at runtime based on the actual object instantiated (C)."},
            {title:"Question 210: Static Variable Hide",tag:"OOP",code:`class A { static int x = 10; }\nclass B extends A { static int x = 20; }\npublic class Main { public static void main(String[] args) { A a = new B(); System.out.print(a.x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Static variables are hidden, not overridden. They are bound at compile time based on the reference type (A)."},
            {title:"Question 211: Interface Default Super",tag:"Interfaces",code:`interface I1 { default void m() { System.out.print("1"); } }\ninterface I2 { default void m() { System.out.print("2"); } }\nclass C implements I1, I2 { public void m() { I1.super.m(); } }`,options:["A) 1","B) 2","C) Compilation Error","D) Runtime Error"],correct:0,exp:"I1.super.m() is the explicit syntax required to resolve the diamond problem and invoke a specific interface's default method."},
            {title:"Question 212: Interface Private Method",tag:"Interfaces",code:`interface I { private void helper() { System.out.print("H"); } default void m() { helper(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Since Java 9, interfaces can contain private methods to share code between default methods."},
            {title:"Question 213: Non-Static Inner Static Outer",tag:"Inner Classes",code:`class Outer { static int x = 10; class Inner { void print() { System.out.print(x); } } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Non-static inner classes can access all outer members, including static variables."},
            {title:"Question 214: Static Inner Non-Static Outer",tag:"Inner Classes",code:`class Outer { int x = 10; static class Inner { void print() { System.out.print(x); } } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Static inner classes cannot access non-static members of the outer class directly without an instance reference."},
            {title:"Question 215: Interface Static Class",tag:"Interfaces",code:`interface I { class C {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interfaces can legally contain classes. These classes are implicitly public and static."},
            {title:"Question 216: Shadow Constructor Param",tag:"Constructors",code:`class A { int x; A(int x) { x = x; } }\npublic class Main { public static void main(String[] args) { System.out.print(new A(10).x); } }`,options:["A) 10","B) 0","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The parameter 'x' shadows the instance variable 'x'. 'x = x' assigns the parameter to itself, leaving the instance variable at 0."},
            {title:"Question 217: This Constructor Param",tag:"Constructors",code:`class A { int x; A(int x) { this.x = x; } }\npublic class Main { public static void main(String[] args) { System.out.print(new A(10).x); } }`,options:["A) 10","B) 0","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The 'this' keyword explicitly refers to the instance variable, successfully assigning the parameter value to it."},
            {title:"Question 218: Static Method Null",tag:"OOP",code:`class A { static void print() { System.out.print("A"); } }\npublic class Main { public static void main(String[] args) { A a = null; a.print(); } }`,options:["A) A","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:0,exp:"Static methods are called on the class, not instances. The compiler maps 'a.print()' to 'A.print()', avoiding any NullPointerException."},
            {title:"Question 219: Covariant Return Wrapper",tag:"Polymorphism",code:`class P { Number get() { return 1; } }\nclass C extends P { Integer get() { return 2; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Covariant returns work properly with wrapper classes because Integer is a direct subclass of Number."},
            {title:"Question 220: Private Override",tag:"Polymorphism",code:`class A { private void m() { System.out.print("A"); } }\nclass B extends A { private void m() { System.out.print("B"); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Private methods are not inherited, so they cannot be overridden. Class B simply defines a brand new, unrelated private method."},
            {title:"Question 221: GetClass Runtime",tag:"OOP",code:`public class Main { public static void main(String[] args) { Object o = new String("S"); System.out.print(o.getClass().getName()); } }`,options:["A) java.lang.Object","B) java.lang.String","C) Compilation Error","D) Runtime Error"],correct:1,exp:"getClass() is evaluated dynamically at runtime and always returns the actual instantiated object's type (String)."},
            {title:"Question 222: Super Last Statement",tag:"Constructors",code:`class A { A() { System.out.print("A"); } }\nclass B extends A { B() { System.out.print("B"); super(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"The super() constructor invocation must be the absolute first statement in the constructor body. Placing it second causes an error."},
            {title:"Question 223: Overload Final Method",tag:"Polymorphism",code:`class A { final void print() {} }\nclass B extends A { void print(int x) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Final methods cannot be OVERRIDDEN, but they can perfectly be OVERLOADED with a different method signature."},
            {title:"Question 224: Interface Var Static",tag:"Interfaces",code:`interface I { int x = 10; }\npublic class Main { public static void main(String[] args) { System.out.print(I.x); } }`,options:["A) 10","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interface variables are implicitly static, allowing them to be accessed directly via the interface name."},
            {title:"Question 225: Abstract Class Static Method",tag:"Abstraction",code:`abstract class A { static void print() { System.out.print("A"); } }\npublic class Main { public static void main(String[] args) { A.print(); } }`,options:["A) A","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Abstract classes can contain fully implemented static methods which can be executed without needing an instance."},
            {title:"Question 226: Blank Final Init",tag:"Constructors",code:`class A { private final int x; A() { x = 10; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"A 'blank final' variable can be declared without initialization as long as it is definitely initialized in every constructor."},
            {title:"Question 227: Init Block Order",tag:"Constructors",code:`class A { { System.out.print("1"); } A() { System.out.print("2"); } }\npublic class Main { public static void main(String[] args) { new A(); } }`,options:["A) 12","B) 21","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Instance initialization blocks are copied into the beginning of every constructor, so they always run before the constructor body."},
            {title:"Question 228: Static Block Inheritance",tag:"Constructors",code:`class A { static { System.out.print("1"); } A() { System.out.print("2"); } }\nclass B extends A { static { System.out.print("3"); } B() { System.out.print("4"); } }\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) 1234","B) 1324","C) 3142","D) Compilation Error"],correct:1,exp:"Static blocks execute on class load (Parent 1, then Child 3). Constructors execute on instantiation (Parent 2, then Child 4)."},
            {title:"Question 229: Interface Constructor",tag:"Interfaces",code:`interface I { I() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Interfaces cannot hold state and cannot be directly instantiated, therefore they strictly cannot have constructors."},
            {title:"Question 230: Enum Custom Constructor",tag:"Enums",code:`enum E { A(10); private int x; E(int x) { this.x = x; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Enums can have instance variables and custom constructors to initialize data for each specific constant."},
            {title:"Question 231: Enum Equality",tag:"Enums",code:`enum E { A, B }\npublic class Main { public static void main(String[] args) { System.out.print(E.A == E.A); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Enum constants are strictly singletons. Using == to compare them safely and reliably returns true."},
            {title:"Question 232: Enum Equals",tag:"Enums",code:`enum E { A, B }\npublic class Main { public static void main(String[] args) { System.out.print(E.A.equals(E.A)); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Enum inherits equals() from java.lang.Enum, which internally just uses ==, safely returning true."},
            {title:"Question 233: Super Field Access",tag:"OOP",code:`class A { protected int x = 10; }\nclass B extends A { int x = 20; void print() { System.out.print(super.x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The 'super' keyword explicitly targets the parent class reference, allowing access to the hidden parent variable x (10)."},
            {title:"Question 234: Final Ref Object Mutation",tag:"OOP",code:`class A { int x = 10; }\npublic class Main { public static void main(String[] args) { final A a = new A(); a.x = 20; System.out.print(a.x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:1,exp:"A final reference means the memory address it points to cannot change. However, the internal state (fields) of that object CAN mutate."},
            {title:"Question 235: Blank Final External Init",tag:"Constructors",code:`public class Main { final int x; public static void main(String[] args) { Main m = new Main(); m.x = 10; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A blank final instance variable must be initialized internally within the class's constructors or blocks, not externally via a reference."},
            {title:"Question 236: Override Remove Checked",tag:"Polymorphism",code:`class P { void f() throws Exception {} }\nclass C extends P { void f() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"An overriding method is fully permitted to drop any or all checked exceptions declared by the parent method."},
            {title:"Question 237: Override Add Checked",tag:"Polymorphism",code:`class P { void f() {} }\nclass C extends P { void f() throws Exception {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"An overriding method cannot throw checked exceptions that are new or broader than those declared by the parent."},
            {title:"Question 238: Multi Interface Same Signature",tag:"Interfaces",code:`interface I1 { void m(); }\ninterface I2 { void m(); }\nclass C implements I1, I2 { public void m() { System.out.print("M"); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Implementing multiple interfaces that share the exact same method signature is perfectly fine; one implementation fulfills both."},
            {title:"Question 239: Static Access Instance Var",tag:"OOP",code:`public class Main { static int x = 10; int y = 20; public static void main(String[] args) { System.out.print(x + y); } }`,options:["A) 30","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A static context (like main) cannot directly access instance variables (like y) because they require an instantiated object."},
            {title:"Question 240: Static Inner Static Method",tag:"Inner Classes",code:`class Outer { static class Inner { static void print() { System.out.print("A"); } } }\npublic class Main { public static void main(String[] args) { Outer.Inner.print(); } }`,options:["A) A","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Static inner classes can hold static methods, which can be invoked directly through the class chain without any instances."},
            {title:"Question 241: Void Constructor Name",tag:"Constructors",code:`public class Main { public void Main() { System.out.print("M"); } public static void main(String[] args) { new Main(); } }`,options:["A) M","B) Prints nothing","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Because it declares a return type (void), 'public void Main()' is treated as a standard method, not a constructor. The default constructor runs and prints nothing."},
            {title:"Question 242: Constructor Return Empty",tag:"Constructors",code:`class A { A() { return; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Constructors are allowed to contain empty 'return;' statements to exit early, just like void methods."},
            {title:"Question 243: Constructor Return Value",tag:"Constructors",code:`class A { A() { return 10; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Constructors strictly cannot return a value. Returning a value causes an immediate compilation error."},
            {title:"Question 244: Identical Names",tag:"Syntax",code:`class A { int A = 10; void A() { System.out.print(A); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Though terrible practice, Java allows a class, a variable, and a method to all share the exact same name without conflicts."},
            {title:"Question 245: Private Child Constructor",tag:"Constructors",code:`class P { public P() {} }\nclass C extends P { private C() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"A child class is free to make its own constructors private, regardless of the parent constructor's visibility."},
            {title:"Question 246: Private Parent Constructor",tag:"Constructors",code:`class P { private P() {} }\nclass C extends P { public C() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"C's constructor attempts an implicit call to super(). Because P's constructor is private, it's invisible to C, causing an error."},
            {title:"Question 247: Anonymous Impl Abstract",tag:"Abstraction",code:`abstract class A { abstract void m(); }\npublic class Main { public static void main(String[] args) { A a = new A() { void m() { System.out.print("A"); } }; a.m(); } }`,options:["A) A","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Anonymous inner classes provide a quick inline implementation for abstract classes and interfaces."},
            {title:"Question 248: Lambda Interface Impl",tag:"Interfaces",code:`interface I { void m(); }\npublic class Main { public static void main(String[] args) { I i = () -> System.out.print("L"); i.m(); } }`,options:["A) L","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interfaces with exactly one abstract method (Functional Interfaces) can be concisely implemented using Lambda expressions."},
            {title:"Question 249: Multi Abstract Functional",tag:"Interfaces",code:`@FunctionalInterface interface I { void m1(); void m2(); }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"The @FunctionalInterface annotation strictly enforces that the interface contains exactly ONE abstract method. Having two breaks this rule."},
            {title:"Question 250: Instance Variable Hiding Cast",tag:"OOP",code:`class P { int x = 10; }\nclass C extends P { int x = 20; }\npublic class Main { public static void main(String[] args) { C c = new C(); System.out.print(((P)c).x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) ClassCastException"],correct:0,exp:"Variables are not polymorphic. Casting the reference to the parent type accesses the parent's hidden variable."}
        ];

        const palettes = [
            "bg-purple-100 text-purple-800", "bg-red-100 text-red-800", 
            "bg-green-100 text-green-800", "bg-yellow-100 text-yellow-800", 
            "bg-blue-100 text-blue-800", "bg-orange-100 text-orange-800", 
            "bg-teal-100 text-teal-800", "bg-indigo-100 text-indigo-800", 
            "bg-pink-100 text-pink-800"
        ];

        function highlight(code) {
            let c = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            c = c.replace(/\bclass\b/g, '___CLASS___'); 
            c = c.replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>');
            c = c.replace(/("[^"]*")/g, '<span class="code-string">$1</span>');
            
            const kws = ['public', 'static', 'void', 'int', 'boolean', 'double', 'float', 'short', 'long', 'char', 'new', 'try', 'catch', 'finally', 'return', 'if', 'else', 'while', 'for', 'switch', 'case', 'break', 'default', 'interface', 'final', 'throw', 'throws', 'enum', 'record', 'default', 'yield', 'volatile', 'transient', 'var', 'protected', 'private', 'abstract', 'extends', 'implements', 'super', 'this', 'sealed', 'permits', 'continue'];
            const kwRegex = new RegExp('\\b(' + kws.join('|') + ')\\b', 'g');
            c = c.replace(kwRegex, '<span class="code-keyword">$1</span>');
            
            const classes = ['String', 'Object', 'Integer', 'Double', 'System', 'Main', 'Parent', 'Child', 'Exception', 'Thread', 'Runnable', 'List', 'ArrayList', 'Map', 'HashMap', 'Set', 'HashSet', 'StringBuilder', 'StringBuffer', 'Math', 'Arrays', 'RuntimeException', 'IOException', 'NullPointerException', 'StackOverflowError', 'Optional', 'PriorityQueue', 'Number', 'Class', 'AutoCloseable', 'Double'];
            const clsRegex = new RegExp('\\b(' + classes.join('|') + ')\\b', 'g');
            c = c.replace(clsRegex, '<span class="code-class">$1</span>');
            
            c = c.replace(/___CLASS___/g, '<span class="code-keyword">class</span>');
            c = c.replace(/(\w+)(?=\()/g, '<span class="code-method">$1</span>');
            
            return c;
        }

        function toggleAnswer(answerId, btnElement) {
            const answerDiv = document.getElementById(answerId);
            if (answerDiv.classList.contains('hidden')) {
                answerDiv.classList.remove('hidden');
                btnElement.textContent = 'Hide Answer';
                btnElement.classList.replace('bg-blue-600', 'bg-gray-600');
                btnElement.classList.replace('hover:bg-blue-700', 'hover:bg-gray-700');
            } else {
                answerDiv.classList.add('hidden');
                btnElement.textContent = 'Show Answer';
                btnElement.classList.replace('bg-gray-600', 'bg-blue-600');
                btnElement.classList.replace('hover:bg-gray-700', 'hover:bg-blue-700');
            }
        }

        // Render optimization for a huge number of DOM nodes
        window.onload = () => {
            const container = document.getElementById('quiz-container');
            
            // Using a DocumentFragment is faster for bulk DOM insertion
            const fragment = document.createDocumentFragment();

            questions.forEach((q, index) => {
                const qId = `ans_${index}`;
                const tagColor = palettes[index % palettes.length];
                
                let optionsHtml = '';
                q.options.forEach((opt, i) => {
                    optionsHtml += `<li><label class="flex items-center cursor-pointer p-1 hover:bg-gray-50 rounded"><input type="radio" name="q${index}" class="mr-3 cursor-pointer w-4 h-4 text-blue-600 focus:ring-blue-500"> ${opt}</label></li>`;
                });

                const div = document.createElement('div');
                div.className = "bg-white rounded-xl shadow-md overflow-hidden border border-gray-200";
                div.innerHTML = `
                    <div class="p-6">
                        <div class="flex items-center justify-between mb-4 border-b border-gray-100 pb-3">
                            <h2 class="text-xl font-bold text-gray-800">${q.title}</h2>
                            <span class="${tagColor} text-xs font-semibold px-2.5 py-1 rounded-full whitespace-nowrap ml-4">${q.tag}</span>
                        </div>
                        <p class="mb-4 text-gray-600 font-medium">What will be the output or error?</p>
                        <div class="bg-[#1e1e1e] rounded-lg p-5 mb-5 overflow-x-auto shadow-inner">
                            <pre class="font-mono text-sm leading-relaxed text-gray-300"><code>${highlight(q.code)}</code></pre>
                        </div>
                        <ul class="space-y-2 mb-6 ml-1 text-gray-700">
                            ${optionsHtml}
                        </ul>
                        <button onclick="toggleAnswer('${qId}', this)" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 px-6 rounded-lg transition duration-200 shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                            Show Answer
                        </button>
                        <div id="${qId}" class="hidden mt-5 p-5 bg-green-50 border-l-4 border-green-500 rounded-r-lg shadow-sm">
                            <p class="font-bold text-green-900 mb-2 text-lg">Answer: ${q.options[q.correct]}</p>
                            <p class="text-green-800 leading-relaxed"><strong>Explanation:</strong> ${q.exp}</p>
                        </div>
                    </div>`;
                fragment.appendChild(div);
            });

            // Clear the loading indicator and append all questions at once
            container.innerHTML = '';
            container.appendChild(fragment);
            
            // Add a small footer
            const footer = document.createElement('div');
            footer.className = "text-center py-8 text-gray-500 text-sm";
            footer.innerHTML = "You've reached the end! If you survived this, you are officially a Java Master. â˜•";
            container.appendChild(footer);
        };
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Output & Error Prediction Quiz (Ultimate 250)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for code blocks */
        pre::-webkit-scrollbar { height: 8px; }
        pre::-webkit-scrollbar-track { background: #1f2937; border-radius: 4px; }
        pre::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .code-keyword { color: #f9a8d4; }
        .code-string { color: #86efac; }
        .code-comment { color: #9ca3af; font-style: italic; }
        .code-class { color: #93c5fd; }
        .code-method { color: #fcd34d; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans antialiased pb-12">

    <header class="bg-blue-600 text-white shadow-lg py-6 mb-8 sticky top-0 z-50">
        <div class="max-w-4xl mx-auto px-4 flex justify-between items-center">
            <div>
                <h1 class="text-3xl font-bold">â˜• Java Brain Teasers</h1>
                <p class="mt-1 text-blue-100 text-sm">The Ultimate 250 Output & Error Prediction Questions</p>
            </div>
            <div class="bg-blue-800 px-4 py-2 rounded-lg text-sm font-semibold shadow-inner border border-blue-700">
                250 Questions
            </div>
        </div>
    </header>

    <main id="quiz-container" class="max-w-4xl mx-auto px-4 space-y-8">
        <!-- Questions load dynamically -->
        <div class="text-center py-12 text-gray-500">
            <svg class="animate-spin h-8 w-8 mx-auto mb-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p>Loading the ultimate challenge...</p>
        </div>
    </main>

    <script>
        const questions = [
            // Part 1: Original 50
            {title:"Question 1: The Classic Overload Trap",tag:"Method Overloading",code:`public class Main {\n    public static void print(Object o) { System.out.println("Object"); }\n    public static void print(String s) { System.out.println("String"); }\n    public static void main(String[] args) { print(null); }\n}`,options:["A) Object","B) String","C) Compilation Error","D) NPE"],correct:1,exp:"The compiler chooses the most specific matching method. String is a subclass of Object, so it wins."},
            {title:"Question 2: Try-Catch-Finally Returns",tag:"Exceptions",code:`public class Main {\n    public static int test() {\n        try { return 1; } \n        catch (Exception e) { return 2; } \n        finally { return 3; }\n    }\n    public static void main(String[] args) { System.out.println(test()); }\n}`,options:["A) 1","B) 2","C) 3","D) Compilation Error"],correct:2,exp:"The finally block always executes. Its return statement silently overrides any previous returns."},
            {title:"Question 3: Execution Order",tag:"Initialization",code:`class A {\n    static { System.out.print("1 "); }\n    { System.out.print("2 "); }\n    A() { System.out.print("3 "); }\n}\npublic class Main {\n    public static void main(String[] args) { new A(); new A(); }\n}`,options:["A) 1 2 3 1 2 3","B) 1 2 3 2 3","C) 2 3 1 2 3","D) 1 2 2 3 3"],correct:1,exp:"Static blocks run once per class load. Instance blocks run before the constructor on every instantiation."},
            {title:"Question 4: Variable Hiding vs Overriding",tag:"Polymorphism",code:`class Parent { int x = 10; void show() { System.out.print("P "); } }\nclass Child extends Parent { int x = 20; void show() { System.out.print("C "); } }\npublic class Main {\n    public static void main(String[] args) {\n        Parent obj = new Child();\n        obj.show(); System.out.print(obj.x);\n    }\n}`,options:["A) P 10","B) C 20","C) C 10","D) P 20"],correct:2,exp:"Methods are dynamically overridden at runtime (Child), but variables are statically hidden at compile time based on reference type (Parent)."},
            {title:"Question 5: String Equality",tag:"String Pool",code:`public class Main {\n    public static void main(String[] args) {\n        String s1 = "Java"; String s2 = new String("Java");\n        System.out.print((s1 == s2) + " " + (s1 == s2.intern()));\n    }\n}`,options:["A) true true","B) false false","C) false true","D) true false"],correct:2,exp:"s2 uses 'new' creating a heap object (false). intern() returns the pool reference which matches s1 (true)."},
            {title:"Question 6: Integer Caching",tag:"Memory",code:`public class Main {\n    public static void main(String[] args) {\n        Integer a = 127, b = 127, c = 128, d = 128;\n        System.out.println((a == b) + " " + (c == d));\n    }\n}`,options:["A) true true","B) false false","C) true false","D) false true"],correct:2,exp:"Java caches Integer values from -128 to 127. Values outside this range create new distinct objects."},
            {title:"Question 7: String Math Precedence",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.println(10 + 20 + "Java" + 10 + 20);\n    }\n}`,options:["A) 30Java30","B) 1020Java1020","C) 30Java1020","D) Compilation Error"],correct:2,exp:"Evaluates left-to-right. 10+20=30. Then '30Java'. After string conversion, remaining operators perform string concatenation."},
            {title:"Question 8: The Zero Division Paradox",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(0.0 / 0.0); }\n}`,options:["A) 0.0","B) Infinity","C) NaN","D) ArithmeticException"],correct:2,exp:"Floating-point division by zero follows IEEE 754. 0.0/0.0 is Not-a-Number (NaN)."},
            {title:"Question 9: The Unreachable Finally",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        try { System.exit(0); } \n        finally { System.out.println("Finally"); }\n    }\n}`,options:["A) Prints 'Finally'","B) Does not print anything","C) Compilation Error","D) Runtime Exception"],correct:1,exp:"System.exit() terminates the JVM immediately, bypassing the finally block entirely."},
            {title:"Question 10: Ternary Type Promotion",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        Object o = true ? new Integer(1) : new Double(2.0);\n        System.out.println(o);\n    }\n}`,options:["A) 1","B) 1.0","C) Compilation Error","D) ClassCastException"],correct:1,exp:"Ternary operator promotes the lower precision type to the higher precision type (Integer becomes Double)."},
            {title:"Question 11: Ambiguous Varargs",tag:"Overloading",code:`public class Main {\n    static void test(int... x) { System.out.print("int"); }\n    static void test(Integer... x) { System.out.print("Integer"); }\n    public static void main(String[] args) { test(1, 2); }\n}`,options:["A) int","B) Integer","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The compiler prefers primitive varargs over wrapper class varargs to avoid autoboxing overhead."},
            {title:"Question 12: List Removal",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        list.add(1); list.add(2); list.add(3); list.remove(1);\n        System.out.println(list);\n    }\n}`,options:["A) [2, 3]","B) [1, 3]","C) [1, 2]","D) Exception"],correct:1,exp:"remove(1) resolves to remove(int index), not remove(Object o). It removes the element at index 1 (which is 2)."},
            {title:"Question 13: Assignment Condition",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        boolean b = false;\n        if (b = true) { System.out.println("Yes"); } \n        else { System.out.println("No"); }\n    }\n}`,options:["A) Yes","B) No","C) Compilation Error","D) Runtime Error"],correct:0,exp:"b = true assigns true to b AND evaluates to true, so the if-block executes."},
            {title:"Question 14: Null Reference Static Call",tag:"Statics",code:`class Test { static void hello() { System.out.print("Hi"); } }\npublic class Main {\n    public static void main(String[] args) {\n        Test t = null; t.hello();\n    }\n}`,options:["A) Hi","B) NullPointerException","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Static methods belong to the class. t.hello() compiles to Test.hello(), avoiding the NPE."},
            {title:"Question 15: Exception Masking",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        try { throw new RuntimeException("Try"); } \n        finally { throw new RuntimeException("Finally"); }\n    }\n}`,options:["A) Throws 'Try'","B) Throws 'Finally'","C) Compilation Error","D) Throws both"],correct:1,exp:"Exceptions thrown in a finally block override/mask any exceptions thrown in the try block."},
            {title:"Question 16: Pass by Value",tag:"References",code:`public class Main {\n    static void change(String s) { s = "New"; }\n    public static void main(String[] args) {\n        String str = "Old"; change(str);\n        System.out.println(str);\n    }\n}`,options:["A) Old","B) New","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Java passes references by value. Reassigning 's' in the method does not affect the original reference."},
            {title:"Question 17: Infinite Construction",tag:"Constructors",code:`class Test {\n    Test() { new Test(); }\n    public static void main(String[] args) { new Test(); }\n}`,options:["A) StackOverflowError","B) OutOfMemoryError","C) Compilation Error","D) Terminates normally"],correct:0,exp:"The constructor recursively calls itself infinitely, blowing up the call stack."},
            {title:"Question 18: Thread Run vs Start",tag:"Multithreading",code:`public class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> System.out.print("T "));\n        t.run(); System.out.print("M");\n    }\n}`,options:["A) T M","B) M T","C) Compilation Error","D) Random Order"],correct:0,exp:"Calling run() executes the code synchronously on the current thread. start() must be used for concurrency."},
            {title:"Question 19: Catch Ordering Trap",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        try { throw new java.io.IOException(); }\n        catch (Exception e) { System.out.print("Exception "); }\n        catch (java.io.IOException e) { System.out.print("IO "); }\n    }\n}`,options:["A) Exception","B) IO","C) Compilation Error","D) Both print"],correct:2,exp:"Compilation Error. Exception catches everything, making the subclass IOException block strictly unreachable."},
            {title:"Question 20: Autoboxing Trap",tag:"Wrappers",code:`public class Main {\n    public static void main(String[] args) {\n        Integer i = null; int j = i; System.out.println(j);\n    }\n}`,options:["A) null","B) 0","C) Compilation Error","D) NullPointerException"],correct:3,exp:"Assigning a null wrapper to a primitive forces an implicit unboxing (i.intValue()), triggering an NPE."},
            {title:"Question 21: StringBuilder Equality",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        StringBuilder s1 = new StringBuilder("J");\n        StringBuilder s2 = new StringBuilder("J");\n        System.out.println(s1.equals(s2));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"StringBuilder does not override equals(). It falls back to Object.equals() which compares memory references."},
            {title:"Question 22: Compound Assignment",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        short s = 5; s += 10; s = s + 5; System.out.println(s);\n    }\n}`,options:["A) 20","B) Compilation Error","C) Runtime Error","D) 0"],correct:1,exp:"s += 10 auto-casts, but s + 5 promotes to int. Assigning an int back to short requires an explicit cast."},
            {title:"Question 23: Map Overwriting",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        Map<String, String> m = new HashMap<>();\n        m.put("A", "1"); m.put("A", "2");\n        System.out.println(m.size());\n    }\n}`,options:["A) 1","B) 2","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Maps cannot have duplicate keys. The second put() simply overwrites the value for key 'A'."},
            {title:"Question 24: String Immutability",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        String s = " Hi "; s.trim(); System.out.println(s.length());\n    }\n}`,options:["A) 2","B) 4","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Strings are immutable. trim() returns a new String, but since it wasn't reassigned, the original 's' remains length 4."},
            {title:"Question 25: Absolute Edge Case",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(Math.abs(Integer.MIN_VALUE)); }\n}`,options:["A) 2147483648","B) 2147483647","C) -2147483648","D) 0"],correct:2,exp:"Integer overflow. The absolute value of MIN_VALUE exceeds MAX_VALUE, wrapping back to a negative number."},
            {title:"Question 26: Float Division by Zero",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(1.0 / 0); }\n}`,options:["A) Compilation Error","B) ArithmeticException","C) Infinity","D) NaN"],correct:2,exp:"Floating-point division by 0 does not throw an exception; it results in Infinity per IEEE 754."},
            {title:"Question 27: Minimum Double Value",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(Math.min(Double.MIN_VALUE, 0.0d)); }\n}`,options:["A) 0.0","B) Double.MIN_VALUE","C) -Infinity","D) Error"],correct:0,exp:"Double.MIN_VALUE is the smallest POSITIVE non-zero fraction. It is greater than 0.0."},
            {title:"Question 28: Not a Number",tag:"Math",code:`public class Main {\n    public static void main(String[] args) { System.out.println(Double.NaN == Double.NaN); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"By definition, NaN is never equal to anything, including itself. Use Double.isNaN() instead."},
            {title:"Question 29: Interface Variables",tag:"Interfaces",code:`interface I { int x = 10; }\npublic class Main implements I {\n    public static void main(String[] args) { x = 20; System.out.println(x); }\n}`,options:["A) 20","B) 10","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Interface variables are implicitly public static final. You cannot reassign a final variable."},
            {title:"Question 30: Unreachable Code",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        while (false) { System.out.println("Hi"); }\n        System.out.println("World");\n    }\n}`,options:["A) Hi World","B) World","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Java prevents compiling strictly unreachable code (while(false) blocks)."},
            {title:"Question 31: Char Addition",tag:"Types",code:`public class Main {\n    public static void main(String[] args) { System.out.println('A' + 'B'); }\n}`,options:["A) AB","B) 131","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The + operator on chars performs arithmetic on their ASCII values: 65 + 66 = 131."},
            {title:"Question 32: Arrays asList Mutation",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        List<String> list = java.util.Arrays.asList("A", "B");\n        list.add("C"); System.out.println(list.size());\n    }\n}`,options:["A) 2","B) 3","C) Compilation Error","D) UnsupportedOperationException"],correct:3,exp:"Arrays.asList returns a fixed-size wrapper. You can change elements, but adding/removing throws exceptions."},
            {title:"Question 33: Empty For Loop",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        for (;;) { System.out.println("Inf"); break; }\n    }\n}`,options:["A) Compilation Error","B) Inf","C) Runtime Error","D) Nothing"],correct:1,exp:"for(;;) is perfectly valid syntax for an infinite loop. The break statement exits it immediately after printing."},
            {title:"Question 34: Finally Returns Again",tag:"Exceptions",code:`public class Main {\n    public static boolean test() {\n        try { return true; } finally { return false; }\n    }\n    public static void main(String[] args) { System.out.print(test()); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The finally block intercepts the return true and forces a return false."},
            {title:"Question 35: The i++ Trap",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        int i = 0; i = i++; System.out.println(i);\n    }\n}`,options:["A) 0","B) 1","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The post-increment yields 0, increments i to 1 in memory, then the assignment overwrites i back to the yielded 0."},
            {title:"Question 36: Optional Null",tag:"Optionals",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.Optional<String> o = java.util.Optional.of(null);\n        System.out.println(o.isPresent());\n    }\n}`,options:["A) true","B) false","C) NullPointerException","D) Compilation Error"],correct:2,exp:"Optional.of() strictly rejects nulls and throws NPE. Use Optional.ofNullable() to allow nulls."},
            {title:"Question 37: Boolean Constructor",tag:"Wrappers",code:`public class Main {\n    public static void main(String[] args) {\n        Boolean b = new Boolean("tRue"); System.out.println(b);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The Boolean String constructor ignores case. Any variation of 'true' resolves to true."},
            {title:"Question 38: Set Addition",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.Set<Integer> set = new java.util.HashSet<>();\n        set.add(1); System.out.println(set.add(1));\n    }\n}`,options:["A) 1","B) true","C) false","D) Compilation Error"],correct:2,exp:"Set.add() returns false if the element is already present in the set."},
            {title:"Question 39: The Null Print",tag:"IO",code:`public class Main {\n    public static void main(String[] args) {\n        Object obj = null; System.out.println(obj);\n    }\n}`,options:["A) null","B) NullPointerException","C) Compilation Error","D) Runtime Error"],correct:0,exp:"println converts null references safely to the string literal 'null'."},
            {title:"Question 40: Overloading Null Cast",tag:"Overloading",code:`public class Main {\n    static void test(String s) { System.out.print("S"); }\n    static void test(Integer i) { System.out.print("I"); }\n    public static void main(String[] args) { test((Integer) null); }\n}`,options:["A) S","B) I","C) Compilation Error","D) NPE"],correct:1,exp:"Explicitly casting null to Integer removes the ambiguity, resolving to the Integer overload."},
            {title:"Question 41: Main Overloading",tag:"Execution",code:`public class Main {\n    public static void main(String[] args) { System.out.print("1"); main(new int[]{}); }\n    public static void main(int[] args) { System.out.print("2"); }\n}`,options:["A) 1","B) 2","C) 12","D) Compilation Error"],correct:2,exp:"The main method can be overloaded. The JVM automatically starts with String[] args, which then manually calls the other."},
            {title:"Question 42: Array Type Safety",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        Object[] arr = new String[2]; arr[0] = 10; System.out.println(arr[0]);\n    }\n}`,options:["A) 10","B) Compilation Error","C) ArrayStoreException","D) NPE"],correct:2,exp:"Arrays are covariant, so compiling succeeds. But at runtime, putting an Integer into a String[] throws ArrayStoreException."},
            {title:"Question 43: Final Reassignment",tag:"Modifiers",code:`public class Main {\n    public static void main(String[] args) {\n        final int x; x = 10; x = 20; System.out.println(x);\n    }\n}`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:2,exp:"A 'blank final' can be assigned exactly once. The second assignment triggers a compiler error."},
            {title:"Question 44: Switch Fallthrough",tag:"Switch",code:`public class Main {\n    public static void main(String[] args) {\n        int x = 5;\n        switch(x) { default: System.out.print("D "); case 1: System.out.print("1"); }\n    }\n}`,options:["A) D","B) D 1","C) Compilation Error","D) 1"],correct:1,exp:"The default block triggers because 5 has no case. Since there is no break, it falls through into case 1."},
            {title:"Question 45: String Literal vs Object",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        String s1 = "Java"; String s2 = "Ja" + "va";\n        System.out.println(s1 == s2);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The compiler performs constant folding on string literals. 'Ja' + 'va' resolves at compile time to the pooled 'Java'."},
            {title:"Question 46: Double NaN Checks",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        double d = Double.NaN; System.out.println(Double.isNaN(d) == (d != d));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Because NaN == NaN is false, d != d is a valid way to check for NaN. Both sides evaluate to true."},
            {title:"Question 47: PriorityQueue Order",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.PriorityQueue<Integer> pq = new java.util.PriorityQueue<>();\n        pq.add(3); pq.add(1); pq.add(2); System.out.println(pq);\n    }\n}`,options:["A) [1, 2, 3]","B) [3, 1, 2]","C) [1, 3, 2]","D) Random"],correct:2,exp:"PriorityQueue is backed by a min-heap array. The smallest is at index 0, but the rest are placed by heap logic, not strict sorting."},
            {title:"Question 48: Static Interface Methods",tag:"Interfaces",code:`interface I { static void run() { System.out.print("R"); } }\nclass Impl implements I {}\npublic class Main {\n    public static void main(String[] args) { Impl.run(); }\n}`,options:["A) R","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:1,exp:"Static methods in interfaces do not inherit. They must be invoked using the interface name: I.run()."},
            {title:"Question 49: Array Cloning",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a = {1}; int[] b = a.clone(); System.out.println(a == b);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"clone() creates a completely new array object in memory, so their memory addresses do not match."},
            {title:"Question 50: Unicode Trap",tag:"Execution",code:`public class Main {\n    public static void main(String[] args) {\n        // \\u000d System.out.print("Surprise");\n    }\n}`,options:["A) Comment ignored","B) Surprise","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Java processes unicode escapes before evaluating syntax. \\u000d acts as a newline, pushing the print statement out of the comment."},

            // Part 2: 51 - 150
            {title:"Question 51: Null Instance",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        Object o = null;\n        System.out.print(o instanceof String);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) NullPointerException"],correct:1,exp:"The instanceof operator safely handles null references, always returning false without throwing an exception."},
            {title:"Question 52: Char Array Print",tag:"IO",code:`public class Main {\n    public static void main(String[] args) {\n        char[] c = {'a', 'b', 'c'};\n        System.out.print(c);\n    }\n}`,options:["A) Memory address","B) abc","C) [a, b, c]","D) Compilation Error"],correct:1,exp:"Unlike other arrays that print memory addresses, System.out.print(char[]) is heavily overloaded to print the string representation directly."},
            {title:"Question 53: Bitwise Inversion",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        int x = ~5;\n        System.out.print(x);\n    }\n}`,options:["A) 5","B) -5","C) 6","D) -6"],correct:3,exp:"The bitwise complement operator ~ inverts all bits. Two's complement math means ~N always equals -(N + 1)."},
            {title:"Question 54: Switch on Null",tag:"Switch",code:`public class Main {\n    public static void main(String[] args) {\n        String s = null;\n        switch(s) { case "a": System.out.print("a"); }\n    }\n}`,options:["A) Prints nothing","B) Compilation Error","C) NullPointerException","D) a"],correct:2,exp:"Switch statements on Strings invoke .hashCode() and .equals() internally. Passing null causes an immediate NPE."},
            {title:"Question 55: Negative Modulo",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(-5 % 2);\n    }\n}`,options:["A) 1","B) -1","C) 2","D) -2"],correct:1,exp:"In Java, the sign of the modulo result always matches the sign of the dividend (the left operand)."},
            {title:"Question 56: Double Brace Leaks",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>() {{ add("A"); }};\n        System.out.print(list.getClass().getName().contains("$"));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Double brace initialization creates an anonymous inner class, hence the dollar sign ($) in its generated class name."},
            {title:"Question 57: Zero Length Arrays",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] arr = new int[0];\n        System.out.print(arr.length);\n    }\n}`,options:["A) 0","B) Compilation Error","C) NegativeArraySizeException","D) NullPointerException"],correct:0,exp:"Java fully permits arrays of length 0. They are not null; they are valid objects with a length property of 0."},
            {title:"Question 58: Integer Constructor Caching",tag:"Memory",code:`public class Main {\n    public static void main(String[] args) {\n        Integer a = new Integer(10);\n        Integer b = new Integer(10);\n        System.out.print(a == b);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"While Integer.valueOf(10) uses the cache, explicitly using 'new' forces new distinct objects on the heap."},
            {title:"Question 59: Rounding Negatives",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Math.round(-1.5));\n    }\n}`,options:["A) -1","B) -2","C) -1.0","D) -2.0"],correct:0,exp:"Math.round() adds 0.5 and floors the result. -1.5 + 0.5 is -1.0, which floors to -1."},
            {title:"Question 60: Unsigned Right Shift",tag:"Bitwise",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(-1 >>> 31);\n    }\n}`,options:["A) -1","B) 0","C) 1","D) 31"],correct:2,exp:"The >>> operator shifts bits to the right and fills the leftmost bits with zero, ignoring the sign bit. -1 is all 1s, shifting 31 leaves a single 1."},
            {title:"Question 61: Split Empty Trails",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        String[] parts = "a:b::".split(":");\n        System.out.print(parts.length);\n    }\n}`,options:["A) 2","B) 3","C) 4","D) 5"],correct:0,exp:"By default, String.split() discards trailing empty strings from the resulting array."},
            {title:"Question 62: Concurrent Removal",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2));\n        for (Integer i : list) { list.remove(i); }\n    }\n}`,options:["A) List is empty","B) Compilation Error","C) ConcurrentModificationException","D) Infinite Loop"],correct:2,exp:"Modifying standard Collections directly while iterating over them with a for-each loop triggers a CME."},
            {title:"Question 63: Float Precision",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(0.1 + 0.2 == 0.3);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"IEEE 754 floats cannot represent 0.1 and 0.2 perfectly. Their sum is 0.30000000000000004, which does not equal 0.3."},
            {title:"Question 64: Map Put Returns",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new HashMap<>();\n        map.put("A", 1);\n        System.out.print(map.put("A", 2));\n    }\n}`,options:["A) 1","B) 2","C) true","D) null"],correct:0,exp:"The Map.put() method returns the PREVIOUS value associated with the specified key, or null if there was no mapping."},
            {title:"Question 65: Set Object Types",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        Set<Short> set = new HashSet<>();\n        set.add((short) 1);\n        System.out.print(set.remove(1));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The remove(Object o) method requires the exact object match. 1 is an Integer, which doesn't match the Short (short)1 in the set."},
            {title:"Question 66: Interface Default Conflicts",tag:"Interfaces",code:`interface A { default void show() {} }\ninterface B { default void show() {} }\nclass C implements A, B {}\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Runtime Error","C) Compilation Error","D) Prints nothing"],correct:2,exp:"Implementing multiple interfaces with matching default methods causes a compilation error unless overridden in the class."},
            {title:"Question 67: Interface Variable Shadowing",tag:"Interfaces",code:`interface A { int X = 1; }\nclass B implements A { int X = 2; }\npublic class Main {\n    public static void main(String[] args) { System.out.print(new B().X); }\n}`,options:["A) 1","B) 2","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Interface variables are static final, but a class implementing the interface can declare its own variable to shadow it."},
            {title:"Question 68: Try With Resources Order",tag:"Exceptions",code:`class R implements AutoCloseable { \n    public void close() { System.out.print("C"); } \n}\npublic class Main {\n    public static void main(String[] args) {\n        try (R r1 = new R(); R r2 = new R()) { }\n    }\n}`,options:["A) CC","B) Compilation Error","C) No Output","D) Exception"],correct:0,exp:"Try-with-resources automatically closes resources. They are closed in the exact REVERSE order of their creation."},
            {title:"Question 69: Covariance Trap",tag:"Generics",code:`public class Main {\n    public static void main(String[] args) {\n        List<Number> list = new ArrayList<Integer>();\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"While arrays are covariant (Number[] = Integer[]), generic collections are strictly invariant to ensure type safety."},
            {title:"Question 70: Type Erasure Match",tag:"Generics",code:`public class Main {\n    public static void main(String[] args) {\n        Class c1 = new ArrayList<String>().getClass();\n        Class c2 = new ArrayList<Integer>().getClass();\n        System.out.print(c1 == c2);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Due to Type Erasure, generic type information is discarded at runtime. Both objects resolve to the raw ArrayList.class."},
            {title:"Question 71: Throwing Broader Exceptions",tag:"Polymorphism",code:`class P { void run() throws java.io.IOException {} }\nclass C extends P { void run() throws Exception {} }\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Deprecation Warning"],correct:1,exp:"An overridden method cannot throw a broader/checked exception than its parent method. Exception is broader than IOException."},
            {title:"Question 72: Covariant Return Types",tag:"Polymorphism",code:`class P { Object get() { return null; } }\nclass C extends P { String get() { return "A"; } }\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Java supports covariant return types. An overridden method can return a more specific subclass (String instead of Object)."},
            {title:"Question 73: Private Member Access",tag:"Encapsulation",code:`class A { private int x=1; void test(A a) { System.out.print(a.x); } }\npublic class Main {\n    public static void main(String[] args) { new A().test(new A()); }\n}`,options:["A) 1","B) Compilation Error","C) Runtime Error","D) IllegalAccessException"],correct:0,exp:"Private access is enforced at the CLASS level, not the instance level. An object can access private fields of another object of the same class."},
            {title:"Question 74: Main Thread Daemon",tag:"Multithreading",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Thread.currentThread().isDaemon());\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The main thread in Java is a non-daemon (user) thread by default."},
            {title:"Question 75: Stream Laziness",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.stream.Stream.of(1).map(i -> { System.out.print("M"); return i; });\n    }\n}`,options:["A) M","B) Prints nothing","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Intermediate stream operations (like map) are lazy. Without a terminal operation (like collect or forEach), they don't execute at all."},
            {title:"Question 76: Effectively Final",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        int x = 1; x++;\n        Runnable r = () -> System.out.print(x);\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Prints 2"],correct:1,exp:"Variables used inside a lambda must be final or effectively final. Modifying 'x' removes its effectively final status."},
            {title:"Question 77: Octal Literals",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        int x = 010;\n        System.out.print(x);\n    }\n}`,options:["A) 10","B) 8","C) 0","D) Compilation Error"],correct:1,exp:"In Java, an integer literal starting with 0 is interpreted as an octal (base-8) number. 010 equals 8 in decimal."},
            {title:"Question 78: ParseInt Octal Trap",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Integer.parseInt("010"));\n    }\n}`,options:["A) 10","B) 8","C) Compilation Error","D) NumberFormatException"],correct:0,exp:"Unlike code literals, parseInt assumes base-10 by default and completely ignores leading zeros. It parses as 10."},
            {title:"Question 79: Hex Literals",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        int x = 0x10;\n        System.out.print(x);\n    }\n}`,options:["A) 10","B) 16","C) 8","D) Compilation Error"],correct:1,exp:"The 0x prefix denotes hexadecimal (base-16). 0x10 equals 16 in decimal."},
            {title:"Question 80: The Long Overflow",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        long l = 1000 * 60 * 60 * 24 * 365;\n        System.out.print(l > 0);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"All math operations happen as ints before assignment. The resulting value overflows the 32-bit int limit and wraps to a negative, THEN assigns to long."},
            {title:"Question 81: Boxed Compile Error",tag:"Wrappers",code:`public class Main {\n    public static void main(String[] args) {\n        Long l = 100;\n        System.out.print(l);\n    }\n}`,options:["A) 100","B) Compilation Error","C) Runtime Error","D) ClassCastException"],correct:1,exp:"The literal 100 is an int. Auto-boxing converts int to Integer, but you cannot assign an Integer to a Long reference. It needs to be 100L."},
            {title:"Question 82: Boolean Spaces",tag:"Wrappers",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Boolean.parseBoolean("True "));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Exception"],correct:1,exp:"parseBoolean strictly checks against 'true' ignoring case. Any whitespace causes the check to fail, returning false."},
            {title:"Question 83: BigDecimal Scale",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        java.math.BigDecimal b1 = new java.math.BigDecimal("0.1");\n        java.math.BigDecimal b2 = new java.math.BigDecimal("0.10");\n        System.out.print(b1.equals(b2));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"BigDecimal.equals compares both value AND scale (number of decimal places). Since the scales differ (1 vs 2), it is false."},
            {title:"Question 84: BigDecimal Compare",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        java.math.BigDecimal b1 = new java.math.BigDecimal("0.1");\n        java.math.BigDecimal b2 = new java.math.BigDecimal("0.10");\n        System.out.print(b1.compareTo(b2));\n    }\n}`,options:["A) 0","B) 1","C) -1","D) false"],correct:0,exp:"Unlike equals, compareTo only considers numerical value and ignores scale. They are mathematically equal, returning 0."},
            {title:"Question 85: Enum Interface",tag:"Enums",code:`interface I {}\nenum Colors implements I { RED, BLUE }\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning"],correct:0,exp:"Enums implicitly extend java.lang.Enum so they cannot extend classes, but they are fully allowed to implement interfaces."},
            {title:"Question 86: Throw Null",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        RuntimeException e = null; throw e;\n    }\n}`,options:["A) NullPointerException","B) Compilation Error","C) Code exits normally","D) RuntimeException"],correct:0,exp:"Attempting to throw a null reference causes the JVM to immediately throw a NullPointerException."},
            {title:"Question 87: Labeled Break",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        lbl: for(int i=0; i<3; i++) { if(i==1) break lbl; System.out.print(i); }\n    }\n}`,options:["A) 0","B) 01","C) 012","D) Compilation Error"],correct:0,exp:"Labels allow breaking out of loops entirely. It prints 0, then when i reaches 1, it breaks the outer label entirely."},
            {title:"Question 88: Precision Loop",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        for(double i=0; i!=10; i+=0.1) {} \n    }\n}`,options:["A) Loop runs 100 times","B) Compilation Error","C) Infinite Loop","D) Runtime Error"],correct:2,exp:"Because 0.1 cannot be represented perfectly in float math, i will never EXACTLY equal 10.0, resulting in an infinite loop."},
            {title:"Question 89: Null Concatenation",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(null + "null");\n    }\n}`,options:["A) nullnull","B) Compilation Error","C) NullPointerException","D) null"],correct:0,exp:"Java's string concatenation operator converts the null reference literal to the string 'null' before appending."},
            {title:"Question 90: Array is Object",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        Object obj = new int[] {1, 2, 3};\n        System.out.print(obj instanceof Object);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) ClassCastException"],correct:0,exp:"In Java, arrays (even arrays of primitives) are fully-fledged Objects and inherit from java.lang.Object."},
            {title:"Question 91: Array Equality",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a = {1}; int[] b = {1};\n        System.out.print(a.equals(b));\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Arrays do not override Object.equals(). It falls back to memory reference comparison (==), requiring Arrays.equals() instead."},
            {title:"Question 92: Math Max",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Math.max(Integer.MIN_VALUE, Integer.MIN_VALUE));\n    }\n}`,options:["A) 2147483647","B) -2147483648","C) 0","D) Compilation Error"],correct:1,exp:"Math.max compares the two values. If both are the lowest possible integer value, it simply returns that value (-2147483648)."},
            {title:"Question 93: Wrapper Classes by Value",tag:"Wrappers",code:`public class Main {\n    static void f(Integer i) { i++; }\n    public static void main(String[] args) { Integer x = 5; f(x); System.out.print(x); }\n}`,options:["A) 5","B) 6","C) Compilation Error","D) NPE"],correct:0,exp:"Wrappers are immutable. i++ unboxes, adds, and boxes to a completely new Integer object locally, leaving x untouched."},
            {title:"Question 94: Set.of Duplicates",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(java.util.Set.of(1, 1).size());\n    }\n}`,options:["A) 1","B) 2","C) Compilation Error","D) IllegalArgumentException"],correct:3,exp:"The Set.of() factory method strictly forbids duplicate elements and immediately throws an IllegalArgumentException."},
            {title:"Question 95: Void Map Value",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.Map.of("a", 1, "a", 2);\n    }\n}`,options:["A) Runs successfully","B) Compilation Error","C) IllegalArgumentException","D) NullPointerException"],correct:2,exp:"Similar to Set.of, Map.of() rejects duplicate keys and throws an IllegalArgumentException immediately."},
            {title:"Question 96: Var with Null",tag:"Types",code:`public class Main {\n    public static void main(String[] args) {\n        var v = null;\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:1,exp:"The 'var' keyword relies on type inference. It cannot infer a type from 'null', causing a compilation error."},
            {title:"Question 97: Invalid Leap Year",tag:"Time",code:`public class Main {\n    public static void main(String[] args) {\n        java.time.LocalDate.of(2023, 2, 29);\n    }\n}`,options:["A) NullPointerException","B) DateTimeException","C) Compilation Error","D) Creates March 1st"],correct:1,exp:"2023 is not a leap year. The strict java.time API validates this and throws a DateTimeException."},
            {title:"Question 98: Pooled String Identity",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) { System.out.print("a" == "a"); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"String literals are pooled. Both instances of the literal point to the exact same reference in memory."},
            {title:"Question 99: Overloading Ambiguity",tag:"Overloading",code:`public class Main {\n    static void f(String s) {} static void f(StringBuffer s) {}\n    public static void main(String[] args) { f(null); }\n}`,options:["A) Compiles fine","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:1,exp:"Neither String nor StringBuffer inherits from the other. The compiler cannot determine which specific method to call for null."},
            {title:"Question 100: XOR Swap Logic",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        boolean b1 = true, b2 = false;\n        System.out.print(b1 ^= b2);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The bitwise XOR assignment operator works on booleans. true XOR false is true, which is assigned back to b1."},
            {title:"Question 101: Nested Interfaces",tag:"Interfaces",code:`class Outer { interface Inner {} }\npublic class Main { public static void main(String[] args) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interfaces defined inside classes are perfectly legal and are implicitly static."},
            {title:"Question 102: Volatile Keyword",tag:"Concurrency",code:`public class Main {\n    volatile int count = 0;\n    void inc() { count++; }\n}`,options:["A) count is thread-safe","B) count++ is not atomic","C) Compilation Error","D) Memory leak"],correct:1,exp:"volatile guarantees visibility between threads, but operations like count++ (read-modify-write) are still NOT atomic."},
            {title:"Question 103: Garbage Collection",tag:"Memory",code:`public class Main {\n    public static void main(String[] args) { System.gc(); }\n}`,options:["A) Forcefully runs GC","B) Suggests GC to run","C) Compilation Error","D) Clears RAM"],correct:1,exp:"System.gc() is only a hint/suggestion to the JVM. It makes no strict guarantee that garbage collection will occur immediately."},
            {title:"Question 104: Multiple Classes",tag:"Syntax",code:`class A {} class B extends A, Object {}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning"],correct:1,exp:"Java does not support multiple inheritance of classes. You cannot use a comma-separated list of classes with 'extends'."},
            {title:"Question 105: Array Index Increment",tag:"Operators",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a = {10, 20}; int i = 0;\n        System.out.print(a[++i]);\n    }\n}`,options:["A) 10","B) 20","C) Compilation Error","D) ArrayIndexOutOfBounds"],correct:1,exp:"Pre-increment increases i to 1 before the array access. a[1] is 20."},
            {title:"Question 106: Primitive Null Cast",tag:"Types",code:`public class Main {\n    public static void main(String[] args) { int x = (int) null; }\n}`,options:["A) Sets to 0","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:1,exp:"Null can be cast to any reference/object type, but it cannot be cast to a primitive type like int."},
            {title:"Question 107: Collections Empty Mod",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.Collections.emptyList().add(1);\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) UnsupportedOperationException","D) NullPointerException"],correct:2,exp:"Collections.emptyList() returns a strictly immutable empty list wrapper. Attempting to modify it throws an exception."},
            {title:"Question 108: Static Block Error",tag:"Exceptions",code:`class A { static { int x = 1/0; } }\npublic class Main {\n    public static void main(String[] args) { new A(); }\n}`,options:["A) ArithmeticException","B) ExceptionInInitializerError","C) Compilation Error","D) No output"],correct:1,exp:"An unchecked exception occurring within a static initialization block gets wrapped into an ExceptionInInitializerError."},
            {title:"Question 109: ValueOf Null Array",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        char[] c = null; System.out.print(String.valueOf(c));\n    }\n}`,options:["A) null","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:2,exp:"Extremely tricky: valueOf(char[]) does not handle nulls safely like valueOf(Object) does. It throws an immediate NPE."},
            {title:"Question 110: ValueOf Null Object",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        Object o = null; System.out.print(String.valueOf(o));\n    }\n}`,options:["A) null","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:0,exp:"Unlike the char[] overload, String.valueOf(Object) contains a safe null check and returns the literal string 'null'."},
            {title:"Question 111: Repeat Zero",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) { System.out.print("A".repeat(0)); }\n}`,options:["A) A","B) Compilation Error","C) Prints nothing (empty)","D) IllegalArgumentException"],correct:2,exp:"The repeat method allows passing 0. It simply returns an empty string."},
            {title:"Question 112: Infinity Equality",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(1.0/0.0 == 2.0/0.0);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) ArithmeticException"],correct:0,exp:"Both resolve to Double.POSITIVE_INFINITY. In IEEE 754 float math, Infinity == Infinity is always true."},
            {title:"Question 113: Cross Infinity",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Double.POSITIVE_INFINITY == Float.POSITIVE_INFINITY);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) ClassCastException"],correct:0,exp:"The Float infinity is promoted to Double. Both represent mathematically equivalent infinities, resulting in true."},
            {title:"Question 114: Generic Number Cast",tag:"Generics",code:`public class Main {\n    public static void main(String[] args) {\n        Number n = 1.0;\n        Integer i = (Integer) n;\n    }\n}`,options:["A) Works fine","B) Compilation Error","C) ClassCastException","D) Runtime Error"],correct:2,exp:"1.0 is autoboxed as a Double. At runtime, attempting to cast a Double object to an Integer triggers a ClassCastException."},
            {title:"Question 115: Catching Errors",tag:"Exceptions",code:`public class Main {\n    public static void main(String[] args) {\n        try { throw new Error(); } catch (Exception e) {}\n    }\n}`,options:["A) Caught successfully","B) Compilation Error","C) Crashes (Error unhandled)","D) Warning"],correct:2,exp:"Errors are not Exceptions. They both extend Throwable, but catch(Exception) will not catch an Error."},
            {title:"Question 116: Thread Yield",tag:"Multithreading",code:`public class Main {\n    public static void main(String[] args) { Thread.yield(); }\n}`,options:["A) Sleep for 1ms","B) Compilation Error","C) Suggests CPU switch","D) Stops thread"],correct:2,exp:"Thread.yield() is a hint to the scheduler that the current thread is willing to yield its current use of a processor."},
            {title:"Question 117: String isEmpty",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) { System.out.print(" ".isEmpty()); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"isEmpty() only returns true if length is exactly 0. A space character has length 1. (Use isBlank() to check for whitespace)."},
            {title:"Question 118: Object Clone",tag:"Object",code:`public class Main {\n    public static void main(String[] args) throws Exception {\n        new Object().clone();\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) CloneNotSupportedException","D) IllegalAccess"],correct:1,exp:"The clone() method in Object is protected. It cannot be called directly from outside the class unless overridden."},
            {title:"Question 119: Boolean Array Default",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        boolean[] b = new boolean[1]; System.out.print(b[0]);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) null"],correct:1,exp:"The default value for boolean elements in an array is always false."},
            {title:"Question 120: Method Reference Target",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.function.Supplier<String> s = Object::toString;\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) ClassCastException"],correct:1,exp:"Object::toString is an instance method. Supplier takes no arguments, leaving the method reference without a target object to call toString on."},
            {title:"Question 121: Instance Method Ref",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.function.Function<Object, String> f = Object::toString;\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) ClassCastException"],correct:0,exp:"Unlike the Supplier, the Function provides the target Object as the first argument, so Object::toString maps perfectly."},
            {title:"Question 122: Transient Fields",tag:"Serialization",code:`class A implements java.io.Serializable { transient int x = 5; }`,options:["A) Serialized as 5","B) Serialized as 0","C) Compilation Error","D) Ignored completely"],correct:1,exp:"Transient fields are excluded from standard serialization. Upon deserialization, primitives default to 0 (or false/null)."},
            {title:"Question 123: IntStream Range",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(java.util.stream.IntStream.range(1, 3).sum());\n    }\n}`,options:["A) 6","B) 3","C) 4","D) Compilation Error"],correct:1,exp:"IntStream.range(start, end) is EXCLUSIVE of the end value. It streams 1 and 2, summing to 3."},
            {title:"Question 124: IntStream Range Closed",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(java.util.stream.IntStream.rangeClosed(1, 3).sum());\n    }\n}`,options:["A) 6","B) 3","C) 4","D) Compilation Error"],correct:0,exp:"rangeClosed is INCLUSIVE. It streams 1, 2, and 3, summing to 6."},
            {title:"Question 125: Record Immutability",tag:"Records",code:`record R(int x) {}\npublic class Main {\n    public static void main(String[] args) { R r = new R(1); r.x = 2; }\n}`,options:["A) Prints nothing","B) Compilation Error","C) Runtime Error","D) Allowed in Java 14+"],correct:1,exp:"Record components are implicitly final. Attempting to modify 'x' triggers a compilation error."},
            {title:"Question 126: Null String Switch",tag:"Switch",code:`public class Main {\n    public static void main(String[] args) {\n        String s = null; switch(s) { default: System.out.print("D"); }\n    }\n}`,options:["A) D","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:2,exp:"Even if a default branch exists, switching on a null string immediately throws an NPE during evaluation."},
            {title:"Question 127: Labeled Continue",tag:"Syntax",code:`public class Main {\n    public static void main(String[] args) {\n        l: for(int i=0;i<2;i++) { for(int j=0;j<2;j++) { continue l; } System.out.print("X"); }\n    }\n}`,options:["A) XX","B) Compilation Error","C) Prints nothing","D) XXXX"],correct:2,exp:"The inner loop continually jumps back to the outer loop 'l' before ever reaching the print statement. It prints nothing."},
            {title:"Question 128: Protected Clone",tag:"OOP",code:`class A { protected Object clone() throws Exception { return super.clone(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Needs interface"],correct:0,exp:"Overriding protected methods without implementing Cloneable compiles fine, but executing it will throw CloneNotSupportedException."},
            {title:"Question 129: Uninitialized Array Print",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a = new int[2]; System.out.print(a);\n    }\n}`,options:["A) [0, 0]","B) Memory address","C) Compilation Error","D) null"],correct:1,exp:"Unless it's a char array, passing an array directly to System.out.print prints its type signature and memory hashcode."},
            {title:"Question 130: Stream Count",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(java.util.stream.Stream.of(1, 2, null).count());\n    }\n}`,options:["A) 2","B) 3","C) NullPointerException","D) Compilation Error"],correct:1,exp:"Stream.count() returns the total number of elements. Null elements are completely valid and are included in the count."},
            {title:"Question 131: FlatMap Type",tag:"Streams",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.stream.Stream.of(1).flatMap(i -> i);\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Returns Stream"],correct:1,exp:"flatMap strictly requires the lambda to return a Stream, not the element itself. Returning 'i' causes a compilation error."},
            {title:"Question 132: Integer Parse Sign",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Integer.parseInt("+10"));\n    }\n}`,options:["A) 10","B) Compilation Error","C) NumberFormatException","D) +10"],correct:0,exp:"parseInt legally accepts an explicit '+' or '-' sign prefix."},
            {title:"Question 133: Var in Lambda",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.function.Consumer<String> c = (var x) -> {};\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Allowed only in Java 8"],correct:0,exp:"Since Java 11, the 'var' keyword is perfectly legal inside implicitly typed lambda expressions."},
            {title:"Question 134: Mixed Var Lambda",tag:"Lambdas",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.function.BiConsumer<String, String> b = (var x, y) -> {};\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Allowed in Java 11+"],correct:1,exp:"You cannot mix 'var' and implicitly typed parameters in a lambda. It must be (var x, var y) or (x, y)."},
            {title:"Question 135: Double Min Value",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(Double.MIN_VALUE > 0);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Unlike Integer, Double.MIN_VALUE is the smallest positive fraction greater than zero, so it is strictly > 0."},
            {title:"Question 136: Float and Double Equality",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(0.1f == 0.1d);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Due to binary precision limits, the float 0.1f expands differently than the double 0.1d. They are not strictly equal."},
            {title:"Question 137: Whole Number Float",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(1.0f == 1.0d);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Unlike fractions like 0.1, whole numbers like 1.0 can be represented perfectly in binary. The float and double match exactly."},
            {title:"Question 138: Instanceof with Interface",tag:"Types",code:`interface I {}\npublic class Main {\n    public static void main(String[] args) {\n        System.out.print("A" instanceof I);\n    }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The compiler allows instanceof checks against interfaces because a subclass could potentially implement it, but it yields false at runtime."},
            {title:"Question 139: Yield in Switch",tag:"Switch",code:`public class Main {\n    public static void main(String[] args) {\n        int x = switch(1) { default -> { yield 2; } };\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Syntax Error"],correct:0,exp:"In modern Java switch expressions, the 'yield' keyword is used to return a value from a block statement."},
            {title:"Question 140: Substring Bounds",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print("A".substring(1, 1));\n    }\n}`,options:["A) A","B) Prints nothing","C) StringIndexOutOfBounds","D) Compilation Error"],correct:1,exp:"substring(begin, end) is inclusive-exclusive. An empty range like (1, 1) is valid and safely returns an empty string."},
            {title:"Question 141: Modulo on Doubles",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        System.out.print(5.5 % 2);\n    }\n}`,options:["A) 1.5","B) 1","C) 1.0","D) Compilation Error"],correct:0,exp:"Unlike some languages, Java fully supports the modulo operator % on floating-point numbers."},
            {title:"Question 142: Arrays AsList Change",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        String[] arr = {"A"}; java.util.List<String> l = java.util.Arrays.asList(arr);\n        l.set(0, "B"); System.out.print(arr[0]);\n    }\n}`,options:["A) A","B) B","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Arrays.asList returns a view backed strictly by the original array. Modifying the list immediately mutates the underlying array."},
            {title:"Question 143: CopyOf Change",tag:"Collections",code:`public class Main {\n    public static void main(String[] args) {\n        java.util.List<String> l1 = new ArrayList<>(java.util.Arrays.asList("A"));\n        java.util.List<String> l2 = java.util.List.copyOf(l1);\n        l1.set(0, "B"); System.out.print(l2.get(0));\n    }\n}`,options:["A) A","B) B","C) Compilation Error","D) Runtime Error"],correct:0,exp:"List.copyOf() makes a truly independent, unmodifiable snapshot. Future changes to the original list do NOT affect it."},
            {title:"Question 144: Null String Value",tag:"Strings",code:`public class Main {\n    public static void main(String[] args) {\n        String s = null; System.out.print(s + 1);\n    }\n}`,options:["A) null1","B) 1","C) NullPointerException","D) Compilation Error"],correct:0,exp:"Java string concatenation automatically converts null references to the text 'null'."},
            {title:"Question 145: Array Type Assignment",tag:"Arrays",code:`public class Main {\n    public static void main(String[] args) {\n        int[] a1 = {1}; Object[] a2 = a1;\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) ClassCastException"],correct:1,exp:"While Integer[] is an Object[], an array of primitives (int[]) is NOT an Object[]. It is just an Object."},
            {title:"Question 146: Enum Ordinal",tag:"Enums",code:`enum E { A, B } \npublic class Main {\n    public static void main(String[] args) { System.out.print(E.B.ordinal()); }\n}`,options:["A) 0","B) 1","C) 2","D) Compilation Error"],correct:1,exp:"The ordinal() method returns the 0-based index of the enum constant. B is the second element, so it returns 1."},
            {title:"Question 147: Transient Constructor",tag:"Constructors",code:`public class Main {\n    transient Main() {}\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Ignored"],correct:1,exp:"The 'transient' keyword can only be applied to fields/variables. It cannot be applied to methods, classes, or constructors."},
            {title:"Question 148: Math Pow Type",tag:"Math",code:`public class Main {\n    public static void main(String[] args) {\n        int x = Math.pow(2, 3);\n    }\n}`,options:["A) 8","B) Compilation Error","C) Runtime Error","D) 0"],correct:1,exp:"Math.pow() always returns a double. You cannot implicitly assign a double to an int without an explicit cast."},
            {title:"Question 149: Wait Outside Sync",tag:"Concurrency",code:`public class Main {\n    public static void main(String[] args) throws Exception {\n        new Object().wait();\n    }\n}`,options:["A) Compiles fine","B) Compilation Error","C) IllegalMonitorStateException","D) Infinite wait"],correct:2,exp:"Calling wait() requires the thread to hold the monitor lock (via synchronized block). Otherwise, it throws IllegalMonitorStateException."},
            {title:"Question 150: Finalizer Deprecation",tag:"Memory",code:`public class Main {\n    @Override protected void finalize() {}\n}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Deprecation Warning"],correct:3,exp:"The finalize() method has been officially deprecated since Java 9 and marked for removal due to unpredictable performance constraints."},

            // Part 3: 151 - 250 (Deep OOP Concepts)
            {title:"Question 151: Constructor Chaining Execution",tag:"Constructors",code:`class A { A() { System.out.print("A"); } }\nclass B extends A { B() { System.out.print("B"); } }\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) A","B) B","C) AB","D) BA"],correct:2,exp:"When a child class is instantiated, it implicitly calls the parent's no-argument constructor first (super()) before executing its own."},
            {title:"Question 152: Implicit Super Failure",tag:"Constructors",code:`class A { A(int x) {} }\nclass B extends A { B() {} }\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Prints nothing"],correct:1,exp:"Class B's default constructor implicitly calls super(). But class A has no default constructor (only parameterized), causing a compile error."},
            {title:"Question 153: Super in Try-Catch",tag:"Constructors",code:`class A { A() throws Exception {} }\nclass B extends A { B() { try { super(); } catch(Exception e) {} } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"The super() constructor call must be the absolute first statement in a constructor. It cannot be wrapped inside a try-catch block."},
            {title:"Question 154: Instance Variable Hiding",tag:"OOP",code:`class P { int x = 10; }\nclass C extends P { int x = 20; }\npublic class Main { public static void main(String[] args) { P p = new C(); System.out.print(p.x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Variables are not polymorphic. They are hidden, not overridden. The reference type (P) dictates which variable is accessed at compile time."},
            {title:"Question 155: Static Method Hiding",tag:"OOP",code:`class P { static void m() { System.out.print("P"); } }\nclass C extends P { static void m() { System.out.print("C"); } }\npublic class Main { public static void main(String[] args) { P p = new C(); p.m(); } }`,options:["A) P","B) C","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Static methods belong to the class and are hidden, not dynamically overridden. The call is resolved at compile time based on the reference type (P)."},
            {title:"Question 156: Private Method Override",tag:"Encapsulation",code:`class P { private void m() { System.out.print("P"); } }\nclass C extends P { public void m() { System.out.print("C"); } }\npublic class Main { public static void main(String[] args) { P p = new C(); p.m(); } }`,options:["A) P","B) C","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Compilation Error. The private method in the parent class is not visible to the Main class, so p.m() cannot be invoked."},
            {title:"Question 157: Final Method Override",tag:"Polymorphism",code:`class A { final void f() {} }\nclass B extends A { void f() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"The final keyword on a method explicitly prevents any subclass from overriding it."},
            {title:"Question 158: Ambiguous Interface Constants",tag:"Interfaces",code:`interface I1 { int X = 10; }\ninterface I2 { int X = 20; }\nclass C implements I1, I2 { public void print() { System.out.print(X); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Implementing multiple interfaces with the same constant variable creates ambiguity. You must specify it as I1.X or I2.X."},
            {title:"Question 159: Abstract Constructor",tag:"Abstraction",code:`abstract class A { A() { System.out.print("A"); } }\nclass B extends A {}\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) Prints nothing","B) Compilation Error","C) Runtime Error","D) A"],correct:3,exp:"Abstract classes cannot be instantiated directly, but they can have valid constructors that are invoked by subclasses during instantiation."},
            {title:"Question 160: This and Super Together",tag:"Constructors",code:`class A { A() { this(1); super(); } A(int x) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Infinite Loop"],correct:1,exp:"Both this() and super() mandate being the absolute first statement in a constructor. Therefore, they can never be used together in the same constructor block."},
            {title:"Question 161: Instanceof Subclass",tag:"OOP",code:`class A {}\nclass B extends A {}\nclass C extends B {}\npublic class Main { public static void main(String[] args) { A a = new C(); System.out.print(a instanceof B); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The actual object is of type C. Since C extends B, the object IS-A B. instanceof resolves to true."},
            {title:"Question 162: Covariant Primitive Returns",tag:"Polymorphism",code:`class P { Object get() { return null; } }\nclass C extends P { int get() { return 1; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Covariant return types only work for reference (object) types. You cannot override an Object return type with a primitive like int."},
            {title:"Question 163: Covariant Array Returns",tag:"Polymorphism",code:`class P { Number[] get() { return null; } }\nclass C extends P { Integer[] get() { return null; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Array types are covariant. Since Integer extends Number, Integer[] is a valid covariant return type for Number[]."},
            {title:"Question 164: Exception Override Check",tag:"Polymorphism",code:`class P { void run() throws RuntimeException {} }\nclass C extends P { void run() throws Exception {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"An overriding method cannot throw a broader or new checked exception (Exception) than the parent method (RuntimeException)."},
            {title:"Question 165: Exception Override Uncheck",tag:"Polymorphism",code:`class P { void run() throws java.io.IOException {} }\nclass C extends P { void run() throws RuntimeException {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Overriding methods are completely free to throw any unchecked (Runtime) exceptions, regardless of what the parent throws."},
            {title:"Question 166: The Runtime This",tag:"Constructors",code:`class A { A() { System.out.print(this.getClass().getSimpleName()); } }\nclass B extends A {}\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) A","B) B","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Even when invoked inside a parent constructor, the 'this' keyword always points to the actual runtime object being constructed (B)."},
            {title:"Question 167: Constructor Polymorphism Trap",tag:"OOP",code:`class P { P() { m(); } void m() { System.out.print("P"); } }\nclass C extends P { int x = 5; void m() { System.out.print(x); } }\npublic class Main { public static void main(String[] args) { new C(); } }`,options:["A) 5","B) P","C) 0","D) Compilation Error"],correct:2,exp:"P's constructor calls the overridden m() in C BEFORE C's instance variables are initialized, so it prints the default value of x (0)."},
            {title:"Question 168: Overload Widen vs Box",tag:"Overloading",code:`public class Main {\n    void f(long l) { System.out.print("L"); }\n    void f(Integer i) { System.out.print("I"); }\n    public static void main(String[] args) { new Main().f(10); }\n}`,options:["A) L","B) I","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Java prefers widening a primitive (int to long) over autoboxing (int to Integer) when resolving method overloads."},
            {title:"Question 169: Overload Box vs Vararg",tag:"Overloading",code:`public class Main {\n    void f(int... i) { System.out.print("V"); }\n    void f(Integer i) { System.out.print("W"); }\n    public static void main(String[] args) { new Main().f(10); }\n}`,options:["A) V","B) W","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Java resolves overloads by preferring autoboxing (int to Integer) over variable arguments (int...)."},
            {title:"Question 170: Overload Vararg vs Array",tag:"Overriding",code:`class P { void m(int... x) { System.out.print("P"); } }\nclass C extends P { void m(int[] x) { System.out.print("C"); } }\npublic class Main { public static void main(String[] args) { P p = new C(); p.m(1); } }`,options:["A) P","B) C","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Varargs (int...) and arrays (int[]) are compiled to the exact same signature. Therefore, C successfully overrides P's method."},
            {title:"Question 171: Cast Parent to Child",tag:"OOP",code:`class P {}\nclass C extends P {}\npublic class Main { public static void main(String[] args) { P p = new P(); C c = (C) p; } }`,options:["A) Compiles fine, runs fine","B) Compilation Error","C) ClassCastException","D) NullPointerException"],correct:2,exp:"You cannot downcast a parent object instance to a child reference. The object in memory is strictly a P, not a C."},
            {title:"Question 172: Overload Equals",tag:"OOP",code:`class A { public boolean equals(A obj) { return true; } }`,options:["A) Overrides Object.equals","B) Overloads Object.equals","C) Compilation Error","D) Runtime Error"],correct:1,exp:"To override, it MUST take an Object parameter: equals(Object obj). Taking type A means it simply overloads the method."},
            {title:"Question 173: Instanceof Null",tag:"OOP",code:`public class Main { public static void main(String[] args) { String s = null; System.out.print(s instanceof String); } }`,options:["A) true","B) false","C) Compilation Error","D) NullPointerException"],correct:1,exp:"The instanceof operator safely checks nulls. Null is not an instance of any class, so it reliably returns false."},
            {title:"Question 174: Null Instanceof Interface",tag:"Interfaces",code:`interface I {}\npublic class Main { public static void main(String[] args) { Main m = null; System.out.print(m instanceof I); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Same as class checks, instanceof gracefully returns false when checking a null reference against an interface."},
            {title:"Question 175: Class Instanceof Interface",tag:"Interfaces",code:`class A {}\ninterface I {}\npublic class Main { public static void main(String[] args) { A a = new A(); System.out.print(a instanceof I); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Compiles fine and returns false. The compiler allows it because a future subclass of A could potentially implement I at runtime."},
            {title:"Question 176: Unrelated Instanceof",tag:"OOP",code:`class A {}\nclass B {}\npublic class Main { public static void main(String[] args) { A a = new A(); System.out.print(a instanceof B); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:2,exp:"Compilation Error. The compiler strictly knows A and B are completely unrelated classes in the hierarchy and prevents the check."},
            {title:"Question 177: Anonymous Abstract",tag:"Abstraction",code:`abstract class A {}\npublic class Main { public static void main(String[] args) { A a = new A() {}; System.out.print(a.getClass().getName().contains("$")); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The curly braces {} instantiate an anonymous inner subclass of the abstract class, which gets a generated name containing a $."},
            {title:"Question 178: Abstract Interface Impl",tag:"Abstraction",code:`interface I { void m1(); void m2(); }\nabstract class A implements I { public void m1() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Needs m2() implemented"],correct:0,exp:"Abstract classes implementing interfaces do NOT need to implement all interface methods. The unimplemented ones remain abstract."},
            {title:"Question 179: Interface Variable Mod",tag:"Interfaces",code:`interface I { int x = 10; }\npublic class Main implements I { public static void main(String[] args) { I.x = 20; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"All variables declared inside an interface are implicitly public, static, and final. They cannot be reassigned."},
            {title:"Question 180: Default Method Super",tag:"Interfaces",code:`interface I { default void m() { System.out.print("I"); } }\nclass C implements I { public void m() { I.super.m(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"I.super.m() is the correct valid syntax for a class to invoke a default method from an interface it implements."},
            {title:"Question 181: Static Inner Class",tag:"Inner Classes",code:`class Outer { static class Inner {} }\npublic class Main { public static void main(String[] args) { Outer.Inner i = new Outer.Inner(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Needs outer instance"],correct:0,exp:"Static inner classes do not require an instance of the outer class to be instantiated."},
            {title:"Question 182: Non-Static Inner Class",tag:"Inner Classes",code:`class Outer { class Inner {} }\npublic class Main { public static void main(String[] args) { Outer.Inner i = new Outer().new Inner(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Non-static inner classes require an instance of the outer class, instantiated using outerObject.new Inner()."},
            {title:"Question 183: Inner Access Outer Private",tag:"Encapsulation",code:`class Outer { private int x = 10; class Inner { void get() { System.out.print(x); } } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Inner classes have full access to all members of the outer class, including private variables."},
            {title:"Question 184: Outer Access Inner Private",tag:"Encapsulation",code:`class Outer { class Inner { private int x = 10; } void get() { System.out.print(new Inner().x); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interestingly, outer classes ALSO have direct access to the private members of their inner classes via an instance."},
            {title:"Question 185: Local Class Final Var",tag:"Inner Classes",code:`public class Main { public static void main(String[] args) { int x = 10; class Local { void print() { System.out.print(x); } } x = 20; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Prints 20"],correct:1,exp:"Local variables accessed by local inner classes must be final or 'effectively final'. Changing x to 20 violates this."},
            {title:"Question 186: Singleton Factory",tag:"OOP",code:`class A { private A() {} static A create() { return new A(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"This is perfectly valid and is the basis for the Singleton and Factory design patterns using private constructors."},
            {title:"Question 187: Enum Constructor Runs",tag:"Enums",code:`enum E { A, B; private E() { System.out.print("E"); } }\npublic class Main { public static void main(String[] args) { E e = E.A; } }`,options:["A) E","B) EE","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Enum constructors execute exactly once for EVERY enum constant when the enum class is loaded into memory (EE)."},
            {title:"Question 188: Enum New",tag:"Enums",code:`enum E { A }\npublic class Main { public static void main(String[] args) { E e = new E(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Enums represent a fixed set of constants. They strictly cannot be manually instantiated using the 'new' keyword."},
            {title:"Question 189: Clone super",tag:"Object",code:`class A implements Cloneable { public Object clone() { return super.clone(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Object.clone() throws the checked CloneNotSupportedException, which must be either caught or declared in the method signature."},
            {title:"Question 190: Override Expand Access",tag:"Polymorphism",code:`class P { void run() {} }\nclass C extends P { protected void run() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Overriding methods are allowed to expand (make more permissive) the access modifier (from package-private to protected)."},
            {title:"Question 191: Override Reduce Access",tag:"Polymorphism",code:`class P { protected void run() {} }\nclass C extends P { void run() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Overriding methods CANNOT reduce visibility (from protected to package-private). This causes a compilation error."},
            {title:"Question 192: Blank Final Constructor",tag:"Constructors",code:`class A { final int x; A() { x = 10; } A(int y) { } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A blank final variable must be definitely assigned in EVERY constructor. The second constructor fails to initialize x."},
            {title:"Question 193: Static Final Constructor",tag:"Constructors",code:`class A { static final int x; A() { x = 10; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Static final variables must be initialized during class loading (at declaration or in a static block), NOT in an instance constructor."},
            {title:"Question 194: Default Equals",tag:"OOP",code:`public class Main {\n    public static void main(String[] args) { Main m1 = new Main(); Main m2 = new Main(); System.out.print(m1.equals(m2)); }\n}`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Unless overridden, Object's default equals() method simply compares memory addresses (==), returning false for two distinct objects."},
            {title:"Question 195: Instance Override Static",tag:"Polymorphism",code:`class P { static void m() {} }\nclass C extends P { void m() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"An instance method cannot override a static method. The compiler strictly forbids this crossover."},
            {title:"Question 196: Record Compact Constructor",tag:"Records",code:`record Point(int x, int y) { Point { if (x < 0) x = 0; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Java Records support 'compact constructors' without formal parameters to validate or adjust data before assignment."},
            {title:"Question 197: Record Field Mod",tag:"Records",code:`record Point(int x, int y) {}\npublic class Main { public static void main(String[] args) { Point p = new Point(1, 2); p.x = 3; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Record components are implicitly private and final. You cannot modify them after the record is created."},
            {title:"Question 198: Sealed Hierarchy",tag:"OOP",code:`sealed class A permits B {}\nfinal class B extends A {}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Sealed classes successfully restrict inheritance. Subclasses defined in the permits clause must be final, sealed, or non-sealed."},
            {title:"Question 199: Sealed Missing Modifier",tag:"OOP",code:`sealed class A permits B {}\nclass B extends A {}`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A permitted subclass of a sealed class must explicitly declare itself as final, sealed, or non-sealed."},
            {title:"Question 200: Null instanceof Object",tag:"OOP",code:`public class Main { public static void main(String[] args) { System.out.print(null instanceof Object); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:1,exp:"null is not an object and does not inherit from Object. The instanceof check safely returns false."},
            {title:"Question 201: Infinite Object Recursion",tag:"Constructors",code:`class A { A a = new A(); }\npublic class Main { public static void main(String[] args) { new A(); } }`,options:["A) Compiles fine","B) Compilation Error","C) StackOverflowError","D) OutOfMemoryError"],correct:2,exp:"When an object is created, it initializes its instance variables, creating another object recursively until the call stack blows up."},
            {title:"Question 202: Static Infinite Object",tag:"Constructors",code:`class A { static A a = new A(); A() { System.out.print("A"); } }\npublic class Main { public static void main(String[] args) { new A(); } }`,options:["A) A","B) AA","C) Compilation Error","D) StackOverflowError"],correct:1,exp:"The static variable initializes exactly once when the class loads (prints A). Then the 'new A()' in main prints the second A."},
            {title:"Question 203: Chained Constructor Super",tag:"Constructors",code:`class P { P(int x) {} }\nclass C extends P { C() { super(10); } C(int x) { this(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"This is valid constructor chaining. The int constructor delegates to the no-arg constructor, which delegates to the parent."},
            {title:"Question 204: Interface Return Conflict",tag:"Interfaces",code:`interface I1 { void run(); }\ninterface I2 { int run(); }\nclass C implements I1, I2 { public void run() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A class cannot implement two interfaces that declare the same method name with incompatible return types."},
            {title:"Question 205: Throw Omission Override",tag:"Polymorphism",code:`class A { void m() throws RuntimeException {} }\nclass B extends A { void m() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Overriding methods are completely permitted to omit (not throw) any exceptions declared by the parent method."},
            {title:"Question 206: Abstract Redeclare Abstract",tag:"Abstraction",code:`abstract class A { abstract void m(); }\nabstract class B extends A { abstract void m(); }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Abstract classes can legally redeclare an abstract method from a parent class without implementing it."},
            {title:"Question 207: Interface Impl Mod Var",tag:"Interfaces",code:`interface I { int x = 10; }\nclass A implements I { void m() { x = 20; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Variables inherited from interfaces are implicitly public static final and cannot be modified."},
            {title:"Question 208: Overload Reference Type",tag:"Overloading",code:`class A { public void m(Object o) { System.out.print("O"); } public void m(String s) { System.out.print("S"); } }\npublic class Main { public static void main(String[] args) { A a = new A(); Object obj = "Hello"; a.m(obj); } }`,options:["A) O","B) S","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Method overloading is resolved statically at compile time based strictly on the reference type (Object), not the runtime type."},
            {title:"Question 209: Override Runtime Type",tag:"Polymorphism",code:`class P { void run() { System.out.print("P"); } }\nclass C extends P { void run() { System.out.print("C"); } }\npublic class Main { public static void main(String[] args) { P p = new C(); p.run(); } }`,options:["A) P","B) C","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Method overriding is resolved dynamically at runtime based on the actual object instantiated (C)."},
            {title:"Question 210: Static Variable Hide",tag:"OOP",code:`class A { static int x = 10; }\nclass B extends A { static int x = 20; }\npublic class Main { public static void main(String[] args) { A a = new B(); System.out.print(a.x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Static variables are hidden, not overridden. They are bound at compile time based on the reference type (A)."},
            {title:"Question 211: Interface Default Super",tag:"Interfaces",code:`interface I1 { default void m() { System.out.print("1"); } }\ninterface I2 { default void m() { System.out.print("2"); } }\nclass C implements I1, I2 { public void m() { I1.super.m(); } }`,options:["A) 1","B) 2","C) Compilation Error","D) Runtime Error"],correct:0,exp:"I1.super.m() is the explicit syntax required to resolve the diamond problem and invoke a specific interface's default method."},
            {title:"Question 212: Interface Private Method",tag:"Interfaces",code:`interface I { private void helper() { System.out.print("H"); } default void m() { helper(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Since Java 9, interfaces can contain private methods to share code between default methods."},
            {title:"Question 213: Non-Static Inner Static Outer",tag:"Inner Classes",code:`class Outer { static int x = 10; class Inner { void print() { System.out.print(x); } } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Non-static inner classes can access all outer members, including static variables."},
            {title:"Question 214: Static Inner Non-Static Outer",tag:"Inner Classes",code:`class Outer { int x = 10; static class Inner { void print() { System.out.print(x); } } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Static inner classes cannot access non-static members of the outer class directly without an instance reference."},
            {title:"Question 215: Interface Static Class",tag:"Interfaces",code:`interface I { class C {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interfaces can legally contain classes. These classes are implicitly public and static."},
            {title:"Question 216: Shadow Constructor Param",tag:"Constructors",code:`class A { int x; A(int x) { x = x; } }\npublic class Main { public static void main(String[] args) { System.out.print(new A(10).x); } }`,options:["A) 10","B) 0","C) Compilation Error","D) Runtime Error"],correct:1,exp:"The parameter 'x' shadows the instance variable 'x'. 'x = x' assigns the parameter to itself, leaving the instance variable at 0."},
            {title:"Question 217: This Constructor Param",tag:"Constructors",code:`class A { int x; A(int x) { this.x = x; } }\npublic class Main { public static void main(String[] args) { System.out.print(new A(10).x); } }`,options:["A) 10","B) 0","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The 'this' keyword explicitly refers to the instance variable, successfully assigning the parameter value to it."},
            {title:"Question 218: Static Method Null",tag:"OOP",code:`class A { static void print() { System.out.print("A"); } }\npublic class Main { public static void main(String[] args) { A a = null; a.print(); } }`,options:["A) A","B) Compilation Error","C) NullPointerException","D) Runtime Error"],correct:0,exp:"Static methods are called on the class, not instances. The compiler maps 'a.print()' to 'A.print()', avoiding any NullPointerException."},
            {title:"Question 219: Covariant Return Wrapper",tag:"Polymorphism",code:`class P { Number get() { return 1; } }\nclass C extends P { Integer get() { return 2; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Covariant returns work properly with wrapper classes because Integer is a direct subclass of Number."},
            {title:"Question 220: Private Override",tag:"Polymorphism",code:`class A { private void m() { System.out.print("A"); } }\nclass B extends A { private void m() { System.out.print("B"); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Private methods are not inherited, so they cannot be overridden. Class B simply defines a brand new, unrelated private method."},
            {title:"Question 221: GetClass Runtime",tag:"OOP",code:`public class Main { public static void main(String[] args) { Object o = new String("S"); System.out.print(o.getClass().getName()); } }`,options:["A) java.lang.Object","B) java.lang.String","C) Compilation Error","D) Runtime Error"],correct:1,exp:"getClass() is evaluated dynamically at runtime and always returns the actual instantiated object's type (String)."},
            {title:"Question 222: Super Last Statement",tag:"Constructors",code:`class A { A() { System.out.print("A"); } }\nclass B extends A { B() { System.out.print("B"); super(); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"The super() constructor invocation must be the absolute first statement in the constructor body. Placing it second causes an error."},
            {title:"Question 223: Overload Final Method",tag:"Polymorphism",code:`class A { final void print() {} }\nclass B extends A { void print(int x) {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Final methods cannot be OVERRIDDEN, but they can perfectly be OVERLOADED with a different method signature."},
            {title:"Question 224: Interface Var Static",tag:"Interfaces",code:`interface I { int x = 10; }\npublic class Main { public static void main(String[] args) { System.out.print(I.x); } }`,options:["A) 10","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interface variables are implicitly static, allowing them to be accessed directly via the interface name."},
            {title:"Question 225: Abstract Class Static Method",tag:"Abstraction",code:`abstract class A { static void print() { System.out.print("A"); } }\npublic class Main { public static void main(String[] args) { A.print(); } }`,options:["A) A","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Abstract classes can contain fully implemented static methods which can be executed without needing an instance."},
            {title:"Question 226: Blank Final Init",tag:"Constructors",code:`class A { private final int x; A() { x = 10; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"A 'blank final' variable can be declared without initialization as long as it is definitely initialized in every constructor."},
            {title:"Question 227: Init Block Order",tag:"Constructors",code:`class A { { System.out.print("1"); } A() { System.out.print("2"); } }\npublic class Main { public static void main(String[] args) { new A(); } }`,options:["A) 12","B) 21","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Instance initialization blocks are copied into the beginning of every constructor, so they always run before the constructor body."},
            {title:"Question 228: Static Block Inheritance",tag:"Constructors",code:`class A { static { System.out.print("1"); } A() { System.out.print("2"); } }\nclass B extends A { static { System.out.print("3"); } B() { System.out.print("4"); } }\npublic class Main { public static void main(String[] args) { new B(); } }`,options:["A) 1234","B) 1324","C) 3142","D) Compilation Error"],correct:1,exp:"Static blocks execute on class load (Parent 1, then Child 3). Constructors execute on instantiation (Parent 2, then Child 4)."},
            {title:"Question 229: Interface Constructor",tag:"Interfaces",code:`interface I { I() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Interfaces cannot hold state and cannot be directly instantiated, therefore they strictly cannot have constructors."},
            {title:"Question 230: Enum Custom Constructor",tag:"Enums",code:`enum E { A(10); private int x; E(int x) { this.x = x; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Enums can have instance variables and custom constructors to initialize data for each specific constant."},
            {title:"Question 231: Enum Equality",tag:"Enums",code:`enum E { A, B }\npublic class Main { public static void main(String[] args) { System.out.print(E.A == E.A); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Enum constants are strictly singletons. Using == to compare them safely and reliably returns true."},
            {title:"Question 232: Enum Equals",tag:"Enums",code:`enum E { A, B }\npublic class Main { public static void main(String[] args) { System.out.print(E.A.equals(E.A)); } }`,options:["A) true","B) false","C) Compilation Error","D) Runtime Error"],correct:0,exp:"Enum inherits equals() from java.lang.Enum, which internally just uses ==, safely returning true."},
            {title:"Question 233: Super Field Access",tag:"OOP",code:`class A { protected int x = 10; }\nclass B extends A { int x = 20; void print() { System.out.print(super.x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:0,exp:"The 'super' keyword explicitly targets the parent class reference, allowing access to the hidden parent variable x (10)."},
            {title:"Question 234: Final Ref Object Mutation",tag:"OOP",code:`class A { int x = 10; }\npublic class Main { public static void main(String[] args) { final A a = new A(); a.x = 20; System.out.print(a.x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) Runtime Error"],correct:1,exp:"A final reference means the memory address it points to cannot change. However, the internal state (fields) of that object CAN mutate."},
            {title:"Question 235: Blank Final External Init",tag:"Constructors",code:`public class Main { final int x; public static void main(String[] args) { Main m = new Main(); m.x = 10; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A blank final instance variable must be initialized internally within the class's constructors or blocks, not externally via a reference."},
            {title:"Question 236: Override Remove Checked",tag:"Polymorphism",code:`class P { void f() throws Exception {} }\nclass C extends P { void f() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"An overriding method is fully permitted to drop any or all checked exceptions declared by the parent method."},
            {title:"Question 237: Override Add Checked",tag:"Polymorphism",code:`class P { void f() {} }\nclass C extends P { void f() throws Exception {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"An overriding method cannot throw checked exceptions that are new or broader than those declared by the parent."},
            {title:"Question 238: Multi Interface Same Signature",tag:"Interfaces",code:`interface I1 { void m(); }\ninterface I2 { void m(); }\nclass C implements I1, I2 { public void m() { System.out.print("M"); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Implementing multiple interfaces that share the exact same method signature is perfectly fine; one implementation fulfills both."},
            {title:"Question 239: Static Access Instance Var",tag:"OOP",code:`public class Main { static int x = 10; int y = 20; public static void main(String[] args) { System.out.print(x + y); } }`,options:["A) 30","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"A static context (like main) cannot directly access instance variables (like y) because they require an instantiated object."},
            {title:"Question 240: Static Inner Static Method",tag:"Inner Classes",code:`class Outer { static class Inner { static void print() { System.out.print("A"); } } }\npublic class Main { public static void main(String[] args) { Outer.Inner.print(); } }`,options:["A) A","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Static inner classes can hold static methods, which can be invoked directly through the class chain without any instances."},
            {title:"Question 241: Void Constructor Name",tag:"Constructors",code:`public class Main { public void Main() { System.out.print("M"); } public static void main(String[] args) { new Main(); } }`,options:["A) M","B) Prints nothing","C) Compilation Error","D) Runtime Error"],correct:1,exp:"Because it declares a return type (void), 'public void Main()' is treated as a standard method, not a constructor. The default constructor runs and prints nothing."},
            {title:"Question 242: Constructor Return Empty",tag:"Constructors",code:`class A { A() { return; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Constructors are allowed to contain empty 'return;' statements to exit early, just like void methods."},
            {title:"Question 243: Constructor Return Value",tag:"Constructors",code:`class A { A() { return 10; } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"Constructors strictly cannot return a value. Returning a value causes an immediate compilation error."},
            {title:"Question 244: Identical Names",tag:"Syntax",code:`class A { int A = 10; void A() { System.out.print(A); } }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Though terrible practice, Java allows a class, a variable, and a method to all share the exact same name without conflicts."},
            {title:"Question 245: Private Child Constructor",tag:"Constructors",code:`class P { public P() {} }\nclass C extends P { private C() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"A child class is free to make its own constructors private, regardless of the parent constructor's visibility."},
            {title:"Question 246: Private Parent Constructor",tag:"Constructors",code:`class P { private P() {} }\nclass C extends P { public C() {} }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"C's constructor attempts an implicit call to super(). Because P's constructor is private, it's invisible to C, causing an error."},
            {title:"Question 247: Anonymous Impl Abstract",tag:"Abstraction",code:`abstract class A { abstract void m(); }\npublic class Main { public static void main(String[] args) { A a = new A() { void m() { System.out.print("A"); } }; a.m(); } }`,options:["A) A","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Anonymous inner classes provide a quick inline implementation for abstract classes and interfaces."},
            {title:"Question 248: Lambda Interface Impl",tag:"Interfaces",code:`interface I { void m(); }\npublic class Main { public static void main(String[] args) { I i = () -> System.out.print("L"); i.m(); } }`,options:["A) L","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:0,exp:"Interfaces with exactly one abstract method (Functional Interfaces) can be concisely implemented using Lambda expressions."},
            {title:"Question 249: Multi Abstract Functional",tag:"Interfaces",code:`@FunctionalInterface interface I { void m1(); void m2(); }`,options:["A) Compiles fine","B) Compilation Error","C) Runtime Error","D) Warning only"],correct:1,exp:"The @FunctionalInterface annotation strictly enforces that the interface contains exactly ONE abstract method. Having two breaks this rule."},
            {title:"Question 250: Instance Variable Hiding Cast",tag:"OOP",code:`class P { int x = 10; }\nclass C extends P { int x = 20; }\npublic class Main { public static void main(String[] args) { C c = new C(); System.out.print(((P)c).x); } }`,options:["A) 10","B) 20","C) Compilation Error","D) ClassCastException"],correct:0,exp:"Variables are not polymorphic. Casting the reference to the parent type accesses the parent's hidden variable."}
        ];

        const palettes = [
            "bg-purple-100 text-purple-800", "bg-red-100 text-red-800", 
            "bg-green-100 text-green-800", "bg-yellow-100 text-yellow-800", 
            "bg-blue-100 text-blue-800", "bg-orange-100 text-orange-800", 
            "bg-teal-100 text-teal-800", "bg-indigo-100 text-indigo-800", 
            "bg-pink-100 text-pink-800"
        ];

        function highlight(code) {
            let c = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            c = c.replace(/\bclass\b/g, '___CLASS___'); 
            c = c.replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>');
            c = c.replace(/("[^"]*")/g, '<span class="code-string">$1</span>');
            
            const kws = ['public', 'static', 'void', 'int', 'boolean', 'double', 'float', 'short', 'long', 'char', 'new', 'try', 'catch', 'finally', 'return', 'if', 'else', 'while', 'for', 'switch', 'case', 'break', 'default', 'interface', 'final', 'throw', 'throws', 'enum', 'record', 'default', 'yield', 'volatile', 'transient', 'var', 'protected', 'private', 'abstract', 'extends', 'implements', 'super', 'this', 'sealed', 'permits', 'continue'];
            const kwRegex = new RegExp('\\b(' + kws.join('|') + ')\\b', 'g');
            c = c.replace(kwRegex, '<span class="code-keyword">$1</span>');
            
            const classes = ['String', 'Object', 'Integer', 'Double', 'System', 'Main', 'Parent', 'Child', 'Exception', 'Thread', 'Runnable', 'List', 'ArrayList', 'Map', 'HashMap', 'Set', 'HashSet', 'StringBuilder', 'StringBuffer', 'Math', 'Arrays', 'RuntimeException', 'IOException', 'NullPointerException', 'StackOverflowError', 'Optional', 'PriorityQueue', 'Number', 'Class', 'AutoCloseable', 'Double'];
            const clsRegex = new RegExp('\\b(' + classes.join('|') + ')\\b', 'g');
            c = c.replace(clsRegex, '<span class="code-class">$1</span>');
            
            c = c.replace(/___CLASS___/g, '<span class="code-keyword">class</span>');
            c = c.replace(/(\w+)(?=\()/g, '<span class="code-method">$1</span>');
            
            return c;
        }

        function toggleAnswer(answerId, btnElement) {
            const answerDiv = document.getElementById(answerId);
            if (answerDiv.classList.contains('hidden')) {
                answerDiv.classList.remove('hidden');
                btnElement.textContent = 'Hide Answer';
                btnElement.classList.replace('bg-blue-600', 'bg-gray-600');
                btnElement.classList.replace('hover:bg-blue-700', 'hover:bg-gray-700');
            } else {
                answerDiv.classList.add('hidden');
                btnElement.textContent = 'Show Answer';
                btnElement.classList.replace('bg-gray-600', 'bg-blue-600');
                btnElement.classList.replace('hover:bg-gray-700', 'hover:bg-blue-700');
            }
        }

        // Render optimization for a huge number of DOM nodes
        window.onload = () => {
            const container = document.getElementById('quiz-container');
            
            // Using a DocumentFragment is faster for bulk DOM insertion
            const fragment = document.createDocumentFragment();

            questions.forEach((q, index) => {
                const qId = `ans_${index}`;
                const tagColor = palettes[index % palettes.length];
                
                let optionsHtml = '';
                q.options.forEach((opt, i) => {
                    optionsHtml += `<li><label class="flex items-center cursor-pointer p-1 hover:bg-gray-50 rounded"><input type="radio" name="q${index}" class="mr-3 cursor-pointer w-4 h-4 text-blue-600 focus:ring-blue-500"> ${opt}</label></li>`;
                });

                const div = document.createElement('div');
                div.className = "bg-white rounded-xl shadow-md overflow-hidden border border-gray-200";
                div.innerHTML = `
                    <div class="p-6">
                        <div class="flex items-center justify-between mb-4 border-b border-gray-100 pb-3">
                            <h2 class="text-xl font-bold text-gray-800">${q.title}</h2>
                            <span class="${tagColor} text-xs font-semibold px-2.5 py-1 rounded-full whitespace-nowrap ml-4">${q.tag}</span>
                        </div>
                        <p class="mb-4 text-gray-600 font-medium">What will be the output or error?</p>
                        <div class="bg-[#1e1e1e] rounded-lg p-5 mb-5 overflow-x-auto shadow-inner">
                            <pre class="font-mono text-sm leading-relaxed text-gray-300"><code>${highlight(q.code)}</code></pre>
                        </div>
                        <ul class="space-y-2 mb-6 ml-1 text-gray-700">
                            ${optionsHtml}
                        </ul>
                        <button onclick="toggleAnswer('${qId}', this)" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 px-6 rounded-lg transition duration-200 shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                            Show Answer
                        </button>
                        <div id="${qId}" class="hidden mt-5 p-5 bg-green-50 border-l-4 border-green-500 rounded-r-lg shadow-sm">
                            <p class="font-bold text-green-900 mb-2 text-lg">Answer: ${q.options[q.correct]}</p>
                            <p class="text-green-800 leading-relaxed"><strong>Explanation:</strong> ${q.exp}</p>
                        </div>
                    </div>`;
                fragment.appendChild(div);
            });

            // Clear the loading indicator and append all questions at once
            container.innerHTML = '';
            container.appendChild(fragment);
            
            // Add a small footer
            const footer = document.createElement('div');
            footer.className = "text-center py-8 text-gray-500 text-sm";
            footer.innerHTML = "You've reached the end! If you survived this, you are officially a Java Master. â˜•";
            container.appendChild(footer);
        };
    </script>
</body>
</html>